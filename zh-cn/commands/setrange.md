重写存储在 _key_ 处的字符串的部分，从指定的偏移开始，为 _value_ 的整个长度。
如果偏移量大于 _key_ 处当前字符串的长度，则用零字节填充字符串使其适应 _offset_。
不存在的键被视为空字符串，因此此命令将确保它保存的字符串足够大，以便能够在 _offset_ 处设置 _value_。

请注意，您可以设置的最大偏移量是2^29 -1（536870911），因为Redis的字符串限制为512兆字节。如果您需要超出这个大小，您可以使用多个键。

**警告**：当设置最后一个可能的字节并且存储在_key_中的字符串值尚未保存字符串值，或者保存了一个小的字符串值时，Redis需要分配所有中间内存，这可能会导致服务器阻塞一段时间。
在2010年的MacBook Pro上，设置字节号536870911（分配512MB）需要大约300毫秒，设置字节号134217728（分配128MB）需要大约80毫秒，设置位号33554432（分配32MB）需要大约30毫秒，设置位号8388608（分配8MB）需要大约8毫秒。
请注意，一旦完成了第一次分配，对于相同的_key_，后续对`SETRANGE`的调用将不会产生分配开销。

## 模式

由于`SETRANGE`和类似的`GETRANGE`命令，您可以将Redis字符串用作具有O(1)随机访问的线性数组。
这在许多实际应用中是非常快速和高效的存储方案。

@examples

基本用法:

```cli
SET key1 "Hello World"
SETRANGE key1 6 "Redis"
GET key1
```

零填充的示例：

```cli
SETRANGE key2 6 "Redis"
GET key2
```
