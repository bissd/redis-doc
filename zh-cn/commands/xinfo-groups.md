该命令返回存储在`<key>`处的流的所有消费者组列表。

默认情况下，每个组仅提供以下信息：

* **name**: 消费者组的名称
* **consumers**: 组中消费者的数量
* **pending**: 组的待处理条目列表（即已传递但尚未确认的消息）的长度（PEL）
* **last-delivered-id**: 传递给组的消费者的最后一条条目的ID
* **entries-read**: 传递给组的消费者的最后一条条目的逻辑“读取计数器”
* **lag**: 正在等待传递给组的消费者的流中的条目数，或者当无法确定该数目时为NULL。

### 消费者组延迟

给定消费者组的滞后是介于组的"entries_read"和流的"entries_added"之间的条目数量。换句话说，它是尚未传递给消费者组的条目数量。

该指标的值和趋势对于做出有关消费者群体的扩展决策非常有帮助。
您可以通过向群体中添加更多的消费者来解决高延迟值的问题，而低值可能表明您可以从群体中删除消费者以缩小规模。

Redis通过保持两个计数器（添加到流中的所有条目的数量和消费者组进行的逻辑读取的数量）来报告消费者组的滞后。
滞后是这两者之间的差异。

流的计数器（`XINFO STREAM` 命令的 `entries_added` 字段）每次 `XADD` 都会增加一，并且在流的生命周期内计算添加到流中的所有条目。

消费者组的计数器`entries_read`是该组已读取的条目的逻辑计数器。
需要注意的是，该计数器只是一个启发式计数器，而不是准确的计数器，因此使用术语"逻辑"。
该计数器试图反映消费者组为了到达当前的"last-delivered-id"而**本应读取**的条目数量。
`entries_read`计数器只在完美的世界中是准确的，也就是消费者组从流的第一个条目开始，并处理所有条目（即，在处理之前没有条目被删除）。

有两种特殊情况是这个机制无法报告延迟的：

1. 创建或设置一个消费者组，使用任意的最后交付ID（分别使用`XGROUP CREATE`和`XGROUP SETID`命令）。
   任意ID是指不是流的第一个条目ID、最后一个条目ID或零（"0-0"）ID的任何ID。
2. 在组的`last-delivered-id`和流的`last-generated-id`之间删除一个或多个条目（使用`XDEL`或修剪操作）。

在这两种情况下，组的阅读计数器被视为无效，并且返回的值被设置为NULL以表示当前无法获取滞后情况。

然而，延迟只是暂时不可用。
随着消费者继续处理消息，在正常运行期间，它会自动恢复。
一旦消费者组将流中的最后一条消息传递给其成员，它将设置正确的逻辑读计数器，并且可以恢复跟踪其延迟。

@examples

```
> XINFO GROUPS mystream
1)  1) "name"
    2) "mygroup"
    3) "consumers"
    4) (integer) 2
    5) "pending"
    6) (integer) 2
    7) "last-delivered-id"
    8) "1638126030001-0"
    9) "entries-read"
   10) (integer) 2
   11) "lag"
   12) (integer) 0
2)  1) "name"
    2) "some-other-group"
    3) "consumers"
    4) (integer) 1
    5) "pending"
    6) (integer) 0
    7) "last-delivered-id"
    8) "1638126028070-0"
    9) "entries-read"
   10) (integer) 1
   11) "lag"
   12) (integer) 1
```
