在流消费者组的上下文中，此命令更改待处理消息的所有权，使新的所有者是作为命令参数指定的消费者。通常情况下，会发生以下情况：

1. 有一个与消费者组关联的流。
2. 通过 `XREADGROUP` 操作，某个消费者 A 在消费者组的上下文中读取一条消息。
3. 作为副作用，该消费者组的 Pending Entries List (PEL) 中创建了一个待处理消息条目：表示消息已经传递给了指定的消费者，但尚未通过 `XACK` 进行确认。
4. 然后突然该消费者永久性失败。
5. 其他消费者可以使用 `XPENDING` 命令检查待处理消息列表中已存在相当长时间的消息。为了继续处理这些消息，它们使用 `XCLAIM` 获取消息的所有权并继续处理。消费者还可以使用 `XAUTOCLAIM` 命令自动扫描和获取待处理消息的所有权。

这种动态在[流介绍文档](/topics/streams-intro)中有明确解释。

请注意，只有在调用`XCLAIM`时，消息的空闲时间超过我们指定的最小空闲时间时，才会被认为是可提取的。由于`XCLAIM`的副作用是重置空闲时间（因为这是对消息进行新尝试处理的结果），两个同时尝试提取消息的消费者永远不会同时成功：只有一个消费者会成功提取消息。这样可以避免以一种琐碎的方式多次处理同一条消息（但在一般情况下，多次处理是可能且不可避免的）。

此外，作为副作用，“XCLAIM”将增加发送消息的尝试次数计数，除非指定了“JUSTID”选项（仅传递消息ID，而不是消息本身）。通过这种方式，由于消费者崩溃导致无法处理消息等原因，将开始出现更大的计数器，并且可以在系统内部进行检测。

`XCLAIM`不会在以下情况下声明消息：

1. 消息在群组 PEL 中不存在（即未被任何消费者读取）。
2. 消息存在于群组 PEL 中，但不在流中本身（即消息已被读取，但未被确认，并且随后被从流中删除，可能是因为修剪或使用 `XDEL`）。

在这两种情况下，回复将不包含对该消息的相应条目（即回复数组的长度可能比提供给`XCLAIM`的ID的数量小）。
在后一种情况下，消息也将从其所在的PEL中被删除。这个特性是在Redis 7.0中引入的。

## 命令选项

该命令有多个选项，但大多数主要用于内部使用，以便将`XCLAIM`或其他命令的效果传输到AOF文件并将相同效果传播到副本，对普通用户来说可能不太有用：

1. `IDLE <ms>`：设置消息的空闲时间（上次投递的时间）。如果未指定IDLE，则假定IDLE为0，即时间计数重置，因为消息现在有一个新的所有者试图处理它。
2. `TIME <ms-unix-time>`：与IDLE相同，但不是相对的毫秒数，而是将空闲时间设置为特定的Unix时间（以毫秒为单位）。这样做可以用于重新生成AOF文件并生成`XCLAIM`命令。
3. `RETRYCOUNT <count>`：将重试计数器设置为指定的值。每次重新传递消息时，此计数器递增。通常，`XCLAIM`不会更改此计数器，它仅在调用XPENDING命令时提供给客户端。这样客户端可以检测异常情况，例如在大量传递尝试之后某些原因导致消息从未被处理。
4. `FORCE`：即使某些指定的ID尚未分配给不同的客户端，也会在PEL中创建待处理消息条目。但消息必须存在于流中，否则将忽略不存在的消息的ID。
5. `JUSTID`：仅返回成功获取的消息的ID数组，而不返回实际消息。使用此选项意味着不会递增重试计数器。

@examples

```
> XCLAIM mystream mygroup Alice 3600000 1526569498055-0
1) 1) 1526569498055-0
   2) 1) "message"
      2) "orange"
```

在上面的例子中，我们声明使用ID为 `1526569498055-0` 的消息，只有当消息至少空闲了一小时而没有原始消费者或其他消费者取得进展（确认或声明它），并将所有权分配给消费者 `Alice`。
