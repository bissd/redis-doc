以原子方式返回并移除存储在`source`中的列表的第一个/最后一个元素（根据`wherefrom`参数确定是头部/尾部），并将存储在`destination`中的列表的第一个/最后一个元素（根据`whereto`参数确定是头部/尾部）推入。

例如：考虑`source`持有列表`a，b，c`，`destination`持有列表`x，y，z`。
执行`LMOVE source destination RIGHT LEFT`会导致`source`持有`a，b`，`destination`持有`c，x，y，z`。

如果`source`不存在，则返回值为`nil`，并且不执行任何操作。
如果`source`和`destination`相同，则操作等同于从列表中删除第一个/最后一个元素，并将其作为列表的第一个/最后一个元素推入，因此可以将其视为列表旋转命令（或者如果`wherefrom`与`whereto`相同，则为无操作）。

该命令用于替代已弃用的 `RPOPLPUSH`。执行`LMOVE RIGHT LEFT`等效。

@examples

```cli
RPUSH mylist "one"
RPUSH mylist "two"
RPUSH mylist "three"
LMOVE mylist myotherlist RIGHT LEFT
LMOVE mylist myotherlist LEFT RIGHT
LRANGE mylist 0 -1
LRANGE myotherlist 0 -1
```

## 模式：可靠队列

Redis常常被用作消息服务器来实现后台任务的处理或其他类型的消息任务。
一种简单的队列形式通常是通过将值推送到生产者方的列表中，并在使用`RPOP`（使用轮询）或者`BRPOP`（如果客户端更适合使用阻塞操作）时，在消费者方等待这些值。

然而，在这种情况下，获取到的队列不是“可靠的”，因为消息可能会丢失，例如在网络出现问题或者消费者在接收到消息后崩溃但尚未处理时。

`LMOVE`（或 `BLMOVE` 用于阻塞变体）提供了一种避免这个问题的方法：消费者获取消息的同时将其推送到“处理中”列表中。一旦消息被处理完毕，它将使用 `LREM` 命令从“处理中”列表中移除该消息。

附加客户端可以监视"processing"列表中的项目，如果这些项目停留的时间过长，将会重新将超时的项目推回队列中。

## 模式：循环列表

使用`LMOVE`命令并且源键和目标键相同，客户端可以逐个访问N个元素的列表，无需使用单个的`LRANGE`操作将完整列表从服务器传输到客户端，时间复杂度为O(N)。

上述模式即使在以下条件下也起作用：

* 有多个客户端循环遍历列表：它们会获取不同的元素，直到列表中的所有元素都被访问过，然后重新开始该过程。
* 即使其他客户端正在不断将新项目添加到列表的末尾。

以上简化了实现一个尽可能快速地持续处理一组项目的系统的过程，其中需要使用N个工作者。
一个例子是一个监测系统，需要检查一组网站是否可访问，并使用并行的工作者以最小的延迟进行检查。

注意，这个工人的实现是非常可扩展和可靠的，即使一条消息丢失，项目仍然保留在队列中，并将在下一次迭代中处理。
