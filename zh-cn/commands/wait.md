这个命令在所有之前的写入命令被至少指定数量的副本成功传输并确认之前，阻塞当前客户端。如果达到了指定的超时时间（以毫秒为单位），即使指定数量的副本尚未达到，命令也会返回。

该命令 **始终返回** 在当前客户端发送`WAIT`命令之前确认写入命令的副本数，无论是达到指定的副本数，还是到达超时时间。

一些说明：

1. 当`WAIT`返回时，保证当前连接上发送的所有前面的写命令将被收到`WAIT`返回的副本数。
2. 如果命令作为`MULTI`事务的一部分发送（Redis 7.0之后，任何不允许阻塞的上下文，如脚本内部），该命令不会阻塞，而是尽快返回先前的写命令得到确认的副本数。
3. 0的超时时间意味着永久阻塞。
4. 由于`WAIT`返回的副本数在失败和成功的情况下都存在，客户端应该检查返回值是否等于或大于其要求的复制级别。

一致性和等待
---

请注意，`WAIT`不会使Redis成为一个强一致性存储：尽管同步复制是复制状态机的一部分，但并不是唯一需要的东西。然而在Sentinel或Redis Cluster故障转移的上下文中，`WAIT`改善了真实世界的数据安全性。

具体来说，如果某个写操作被传输到一个或多个副本，那么如果主节点发生故障，我们更有可能（但不保证）能够在故障转移期间晋升接收到写操作的副本：无论是Sentinel还是Redis Cluster都会尽力将最佳副本晋升为新的主节点。

然而，这只是一个尽力而为的尝试，因此仍有可能在多个副本间同步写入数据时丢失数据。

实施细节
---

自从引入了部分与副本重新同步（PSYNC功能）以来，Redis副本异步地向其主节点发送已在复制流中处理的偏移量。这在多种方式下被使用：

# 检测超时的副本。
# 在断开连接后执行部分重新同步。
# 实现`WAIT`功能。

就`WAIT`的具体实现而言，对于每个客户端，Redis会记住在给定客户端的上下文中执行给定写命令时所产生的复制流的复制偏移量。当调用`WAIT`时，Redis会检查指定数量的副本是否已确认该偏移量或更大的偏移量。

@examples

```
> SET foo bar
OK
> WAIT 1 0
(integer) 1
> WAIT 2 1000
(integer) 1
```

在下面的示例中，第一次调用`WAIT`不使用超时，并要求写入到达1个副本。 它成功返回。 而在第二次尝试中，我们设置了一个超时，并要求写入两个副本。 由于只有一个副本可用，在一秒后，`WAIT`解除阻塞并返回1，达到的副本数量。
