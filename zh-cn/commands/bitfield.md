本命令将 Redis 字符串视为位数组，并能够处理不对齐的偏移量和不同位宽的特定整数字段。在实际使用中，您可以使用此命令设置位偏移量为1234的5位有符号整数的特定值，从偏移量4567检索31位无符号整数。类似地，该命令处理指定整数的递增和递减，提供用户可以配置的溢出和下溢行为的保证和规定行为。

`BITFIELD` 能够在同一命令调用中操作多个位字段。它接受要执行的操作列表，并返回一个与参数列表中的相应操作匹配的回复数组。

例如下面的命令将在位偏移100处递增一个5位有符号整数，并获取位偏移0处的4位无符号整数的值：

    > BITFIELD mykey INCRBY i5 100 1 GET u4 0
    1) (integer) 1
    2) (integer) 0

请注意：

1. 使用`!GET`命令访问当前字符串长度之外的位（包括键不存在的情况），将会导致操作被执行，就好像缺失的部分都由设置为0的位组成。
2. 使用`!SET`或`!INCRBY`命令访问当前字符串长度之外的位，将会扩展字符串长度，并根据最远的位进行零填充，以满足所需的最小长度。

## 支持的子命令和整数编码

以下是支持的命令列表。

* **GET** `<encoding>` `<offset>` -- 返回指定的位字段。
* **SET** `<encoding>` `<offset>` `<value>` -- 设置指定的位字段并返回其旧值。
* **INCRBY** `<encoding>` `<offset>` `<increment>` -- 增加或减少（如果给定负数的增量）指定的位字段并返回新值。

还有另一个子命令，它只通过设置溢出行为来改变连续的`!INCRBY`和`!SET`子命令的行为：

* **溢出** `[WRAP|SAT|FAIL]`

在期望整数编码的地方，可以通过在整数编码之前加上 `i` 表示有符号整数，加上 `u` 表示无符号整数，并附上整数编码的位数。例如，`u8` 是一个8位的无符号整数，`i16` 是一个16位的有符号整数。

支持的编码方式对于有符号整数最多为64位，对于无符号整数最多为63位。由于目前Redis协议无法返回64位无符号整数作为回复，这是对无符号整数的限制。

##

有两种方法可以指定位字段命令中的偏移量。
如果指定的是没有任何前缀的数字，则将其用作字符串中以零为基础的位偏移量。

然而，如果偏移量前缀带有`#`字符，则指定的偏移量将乘以整数编码的宽度，例如：

    BITFIELD mystring SET i8 #0 100 SET i8 #1 200

将第一个 i8 整数设置在偏移量为 0 的位置，将第二个 i8 设置在偏移量为 8 的位置。
这样，如果您想要一个给定大小的纯整数数组，您就不必在客户端内部进行计算了。

## 溢出控制

使用`OVERFLOW`命令，用户可以通过指定以下行为之一来微调增量或减量溢出（或下溢）的行为:

* **WRAP**: 对带符号和无符号整数进行包装。对于无符号整数，包装操作类似于对整数可以包含的最大值进行取模运算（C标准行为）。对于带符号整数，包装意味着溢出重置为最负值，下溢重置为最正值，例如如果一个 `i8` 整数被设置为值为127，将其增加1将得到 `-128`。
* **SAT**: 使用饱和算术，在下溢时，值设为最小整数值，在上溢时，设为最大整数值。例如，从值为120的 `i8` 整数开始，以增量10递增，将得到值为127，进一步递增将始终保持在127。下溢时同样也是如此，但值被阻止在最负值。
* **FAIL**: 在此模式中，不对检测到的溢出或下溢执行任何操作。相应的返回值被设置为NULL，以向调用者信号发送条件。

请注意，每个`OVERFLOW`语句仅影响其后的`!INCRBY`和`!SET`子命令，直到下一个`OVERFLOW`语句。

默认情况下，如果没有另外指定，将使用**WRAP**。

    > BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
    1) (integer) 1
    2) (integer) 1
    > BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
    1) (integer) 2
    2) (integer) 2
    > BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
    1) (integer) 3
    2) (integer) 3
    > BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
    1) (integer) 0
    2) (integer) 3

下面是“溢出失败”返回NULL的示例。

    > BITFIELD mykey OVERFLOW FAIL incrby u2 102 1
    1) (nil)

## 动机

此命令的动机是能够将许多小整数存储为单个大位图（或分段存储在几个键上，以避免有巨大的键），这样非常节省内存，并为 Redis 的应用开辟了新的用例，特别是在实时分析领域。这些用例受到以可控方式指定溢出的支持。

有趣的事实：Reddit在2017年愚人节项目[r/place](https://reddit.com/r/place)是使用[Redis BITFIELD命令](https://redditblog.com/2017/04/13/how-we-built-rplace/)构建的，以便为合作画布提供内存表示。

## 性能考虑

通常情况下，`BITFIELD` 是一个快速的命令，但需要注意的是，访问当前短字符串的远端位将触发一个可能比执行已经存在的位上的命令更昂贵的分配。

## 位的顺序

`BITFIELD`使用的表示形式将位图视为第一个字节最高有效位为位号0，以此类推，因此例如将一个5位无符号整数设置为值23，偏移量为7，而位图之前设置为全零，则会产生以下表示形式：

    +--------+--------+
    |00000001|01110000|
    +--------+--------+

在偏移量和整数大小对齐到字节边界时，这与大端字节顺序是相同的，但当不存在这种对齐时，了解字节内部的位的顺序也很重要。
