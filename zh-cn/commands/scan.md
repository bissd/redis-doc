`SCAN`命令及其相关命令`SSCAN`，`HSCAN`和`ZSCAN`用于按顺序逐个迭代一系列元素。

* `SCAN`迭代当前选定的Redis数据库中的键集。
* `SSCAN`迭代Set类型的元素。
* `HSCAN`迭代Hash类型的字段及其关联的值。
* `ZSCAN`迭代Sorted Set类型的元素及其关联的分数。

由于这些命令允许逐步迭代，每次调用只返回少量元素，因此它们可以在生产环境中使用，而不会像`KEYS`或`SMEMBERS`命令那样在针对大量键或元素的集合时阻塞服务器很长时间（甚至几秒钟）。

然而，尽管像`SMEMBERS`这样的命令能够提供给定时刻集合中的所有元素，但`SCAN`命令系列只能对返回的元素提供有限的保证，因为在迭代过程中，我们要逐步迭代的集合可能会发生变化。

注意，`SCAN`、`SSCAN`、`HSCAN`和`ZSCAN`的工作原理非常相似，因此本文档涵盖了这四个命令。但是，显而易见的区别是，在`SSCAN`、`HSCAN`和`ZSCAN`的情况下，第一个参数是保存Set、Hash或Sorted Set值的键的名称。`SCAN`命令不需要任何键名参数，因为它迭代当前数据库中的键，所以迭代的对象是数据库本身。

## SCAN基础用法

SCAN是基于游标的迭代器。这意味着在每次调用命令时，服务器都会返回一个更新的游标，用户需要在下一次调用中将其作为游标参数使用。

当光标设置为0时，迭代开始，直到服务器返回的光标为0为止。以下是一个SCAN迭代的示例：

```
redis 127.0.0.1:6379> scan 0
1) "17"
2)  1) "key:12"
    2) "key:8"
    3) "key:4"
    4) "key:14"
    5) "key:16"
    6) "key:17"
    7) "key:15"
    8) "key:10"
    9) "key:3"
   10) "key:7"
   11) "key:1"
redis 127.0.0.1:6379> scan 17
1) "0"
2) 1) "key:5"
   2) "key:18"
   3) "key:0"
   4) "key:2"
   5) "key:19"
   6) "key:13"
   7) "key:6"
   8) "key:9"
   9) "key:11"
```

在上面的示例中，第一个调用将零作为游标来开始迭代。第二个调用使用前一个调用返回的游标作为回复的第一个元素，即17。

正如你所看到的，**SCAN 返回值**是一个包含两个值的数组：第一个值是下一次调用时要使用的新光标，第二个值是一个元素数组。

由于第二次调用返回的游标为0，服务器向调用者发出信号表明迭代已完成，并且集合已完全遍历。以游标值0开始迭代，并调用`SCAN`直到再次返回的游标值为0被称为**完整迭代**。

## 返回值

`SCAN`，`SSCAN`，`HSCAN`和`ZSCAN`返回一个包含两个元素的多个回复，其中第一个元素是表示无符号64位数的字符串（游标），第二个元素是带有元素数组的多个回复。

* `SCAN` 数组元素是一个键列表。
* `SSCAN` 数组元素是一个集合成员列表。
* `HSCAN` 数组元素包含两个元素，一个是哈希的字段，一个是其对应的值。
* `ZSCAN` 数组元素包含两个元素，一个是有序集合的成员，一个是其关联的分数。

扫描保证

`SCAN` 命令和 `SCAN` 命令族中的其他命令能够向用户提供与完整迭代相关的一组保证。

* 完全迭代始终会检索从开始到结束期间存在于集合中的所有元素。这意味着，如果在迭代开始时集合中存在给定元素，并且在迭代结束时仍然存在，则`SCAN`在某一时刻将其返回给用户。
* 完全迭代永远不会返回从开始到结束期间未在集合中存在的任何元素。因此，如果一个元素在迭代开始之前被移除，并且在整个迭代过程中都没有被重新添加到集合中，`SCAN`确保该元素将永远不会被返回。

然而，由于`SCAN`几乎没有与之相关联的状态（仅仅是光标），它具有以下缺点：

* 可能会多次返回给定元素。应用程序需要处理重复元素的情况，例如只使用返回的元素来执行在多次重新应用时是安全的操作。
* 在完整迭代期间未始终存在于集合中的元素可能被返回或不被返回：这是不确定的。

每个SCAN调用返回的元素数量

“SCAN”家族函数不能保证每次调用返回的元素数量在给定范围内。这些命令也允许返回零个元素，只要返回的游标不为零，客户端就不应认为迭代已完成。

然而，返回的元素数量是合理的，也就是说，实际上当遍历一个大的集合时，`SCAN` 可能返回一些几十个元素左右的数量；当遍历的集合足够小，可以以编码数据结构的形式在一次调用中返回集合的所有元素（这对于小型集合，哈希和有序集合都是可能的）。

然而，用户可以使用**COUNT**选项调整每次调用返回的元素数量的数量级。

## COUNT选项

尽管`SCAN`在每次迭代返回的元素数量上没有提供保证，但可以使用**COUNT**选项经验性地调整`SCAN`的行为。基本上，使用COUNT选项，用户可以指定在每次调用中应完成多少工作以从集合中检索元素。这只是一个提示，用于实现，但一般来说，这是您可以从实现中大部分时间所期望的。

* 默认的 `COUNT` 值为 10。
* 当迭代键空间或由哈希表表示的大型 Set、Hash 或 Sorted Set（假设没有使用 **MATCH** 选项）时，服务器通常会每次返回 *count* 或稍多于 *count* 个元素。请查看本文档后面的 *为什么 SCAN 可能会一次返回所有元素* 部分。
* 当迭代作为 intsets（由整数组成的小型集合）编码的 Set、以及编码为 ziplists（由小型个别值组成的小型哈希和集合）的 Hashes 和 Sorted Sets 时，通常无论 `COUNT` 值如何，所有元素都会在第一个 `SCAN` 调用中返回。

重要提示：**不需要在每次迭代中使用相同的COUNT值**。调用者可以根据需要在每次迭代中更改计数，只要下一次调用中传入的游标是前一次命令中获取到的游标即可。

## 匹配选项

可以仅迭代与给定的通配符样式匹配的元素，类似于`KEYS`命令只接受模式作为其唯一参数的行为。

只需在`SCAN`命令的末尾附加`MATCH <pattern>`参数即可实现此操作（适用于所有`SCAN`系列命令）。

这是使用 **MATCH** 进行迭代的示例：

```
redis 127.0.0.1:6379> sadd myset 1 2 3 foo foobar feelsgood
(integer) 6
redis 127.0.0.1:6379> sscan myset 0 match f*
1) "0"
2) 1) "foo"
   2) "feelsgood"
   3) "foobar"
redis 127.0.0.1:6379>
```

需要注意的是，**MATCH**筛选器是在从集合中检索元素之后应用的，就在将数据返回给客户端之前。这意味着如果模式在集合中匹配了很少的元素，`SCAN`在大多数迭代中可能不会返回任何元素。下面是一个示例：

```
redis 127.0.0.1:6379> scan 0 MATCH *11*
1) "288"
2) 1) "key:911"
redis 127.0.0.1:6379> scan 288 MATCH *11*
1) "224"
2) (empty list or set)
redis 127.0.0.1:6379> scan 224 MATCH *11*
1) "80"
2) (empty list or set)
redis 127.0.0.1:6379> scan 80 MATCH *11*
1) "176"
2) (empty list or set)
redis 127.0.0.1:6379> scan 176 MATCH *11* COUNT 1000
1) "0"
2)  1) "key:611"
    2) "key:711"
    3) "key:118"
    4) "key:117"
    5) "key:311"
    6) "key:112"
    7) "key:111"
    8) "key:110"
    9) "key:113"
   10) "key:211"
   11) "key:411"
   12) "key:115"
   13) "key:116"
   14) "key:114"
   15) "key:119"
   16) "key:811"
   17) "key:511"
   18) "key:11"
redis 127.0.0.1:6379>
```

正如您所看到的，大多数调用返回零个元素，但在最后一个调用中，使用了`COUNT`为1000的命令，以强制该迭代进行更多的扫描。


## TYPE选项

您可以使用`!TYPE`选项来请求`SCAN`只返回与给定`type`匹配的对象，从而允许您遍历数据库，查找特定类型的键。**TYPE**选项仅适用于全数据库的`SCAN`，而不适用于`HSCAN`或`ZSCAN`等命令。

`type` 参数是与 `TYPE` 命令返回的相同字符串名称。请注意，某些 Redis 类型（例如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfields）可能在内部使用其他 Redis 类型（例如 string 或 zset）来实现，因此无法通过 `SCAN` 与同一类型的其他键区分开来。例如，一个 ZSET 和 GEOHASH：

```
redis 127.0.0.1:6379> GEOADD geokey 0 0 value
(integer) 1
redis 127.0.0.1:6379> ZADD zkey 1000 value
(integer) 1
redis 127.0.0.1:6379> TYPE geokey
zset
redis 127.0.0.1:6379> TYPE zkey
zset
redis 127.0.0.1:6379> SCAN 0 TYPE zset
1) "0"
2) 1) "geokey"
   2) "zkey"
```

需要注意的是，**类型**过滤器也是在从数据库检索元素之后应用的，因此该选项不能减少服务器完成完整迭代所需的工作量，对于稀有类型，您可能在许多迭代中都不会收到任何元素。

多个并行迭代

同一时间内，无限数量的客户端可以迭代同一集合，因为迭代器的完整状态都存储在游标中，每次调用都会将游标提供给客户端。服务器端不会产生任何状态。

## 在中途终止迭代

由于没有状态服务器端，但完整状态由游标捕获，因此调用者在没有以任何方式向服务器发出信号的情况下可以随时终止迭代的一半。可以开始无数次迭代而无任何问题地永不终止。

## 以损坏的游标调用SCAN

调用 `SCAN` 使用破损、负数、超出范围或其他无效的游标将导致未定义行为，但永远不会导致崩溃。未定义的是 `SCAN` 实现无法再保证返回元素的保证。

唯一有效的光标使用方式是：

* 在开始迭代时，光标值为0
* 光标是上一次调用SCAN返回的，以便继续迭代。

终止保证

只有在迭代集合的大小保持在给定的最大大小时，`SCAN`算法才能保证终止，否则，对一个始终增长的集合进行迭代可能导致`SCAN`无法完整迭代而无法终止。

这在直观上很容易理解：如果集合增长，就需要做越来越多的工作来访问所有可能的元素，并且迭代的终止能力取决于对`SCAN`的调用次数以及其COUNT选项值与集合增长速度的比较。

为什么 SCAN 可能在一次调用中返回聚合数据类型的所有项？

在`COUNT`选项的文档中，我们说明有时这个命令族可能会在单个调用中返回Set、Hash或Sorted Set的所有元素，而不管`COUNT`选项的值如何。这种情况发生的原因是，基于游标的迭代器只能在我们扫描的聚合数据类型被表示为哈希表时实现，而且只有在这种情况下才有用。然而，Redis使用一种[内存优化](/topics/memory-optimization)，其中小的聚合数据类型在达到一定数量的项目或单个元素的给定最大大小之前，使用紧凑的单分配打包编码来表示。当出现这种情况时，`SCAN`没有有意义的游标可返回，并且必须一次迭代整个数据结构，因此它唯一明智的行为就是一次性返回所有内容。

然而，一旦数据结构变得更大并被提升为使用实际哈希表，`SCAN` 命令系列将恢复正常行为。注意，由于返回所有元素的特殊行为仅适用于小聚合，因此不会影响命令复杂性或延迟。然而，以实际哈希表转换的确切限制是[用户可配置的](/topics/memory-optimization)，因此在单个调用中可返回的元素数量的最大值取决于聚合数据类型的大小以及使用紧凑表示的能力。

还要注意，这种行为只在`SSCAN`、`HSCAN`和`ZSCAN`中出现。`SCAN`本身从不显示这种行为，因为键空间始终由哈希表表示。

## 更多阅读

有关管理键的更多信息，请参阅《The Redis Keyspace》教程。

## 更多案例

哈希值的迭代。

```
redis 127.0.0.1:6379> hmset hash name Jack age 33
OK
redis 127.0.0.1:6379> hscan hash 0
1) "0"
2) 1) "name"
   2) "Jack"
   3) "age"
   4) "33"
```
