如果 `key` 不存在，则设置 `key` 的值为字符串 `value`。
在这种情况下，它等于 `SET`。
如果 `key` 已经有一个值，则不执行任何操作。
`SETNX`是 "**SET** if **N**ot e**X**ists" 的简写。

@examples

```cli
SETNX mykey "Hello"
SETNX mykey "World"
GET mykey
```

## 设计模式：使用`!SETNX`进行锁定

请注意：

1. 为了更好的保证和容错性，我们不鼓励使用以下模式，而是推荐使用[Redlock算法](https://redis.io/topics/distlock)，该算法的实现稍微复杂一些。
2. 我们仍然会记录旧的模式，因为某些现有的实现将此页面作为参考链接。而且这也是一个有趣的示例，说明了如何使用Redis命令来构建编程原语。
3. 无论如何，即使假设有一个单实例的锁原语，从2.6.12开始，使用`SET`命令获取锁，使用一个简单的Lua脚本释放锁，可以创建一个更简单的、等价于此处讨论的锁原语。该模式在`SET`命令页面中有记录。

可以使用`SETNX`，并且在历史上确实被用作锁原语。例如，为了获取键`foo`的锁，客户端可以尝试以下操作：

```
SETNX lock.foo <current Unix time + lock timeout + 1>
```

如果 `SETNX` 返回 `1` ，表示客户端已经获得锁定，并将 `lock.foo` 键设置为锁定应该不再被视为有效的 Unix 时间。客户端将在后续使用 `DEL lock.foo` 来释放锁定。

如果`SETNX`返回`0`，表示该键已被其他客户端锁定。
如果是非阻塞锁定，则可以返回给调用者，或者进入循环重试持有锁定，直到成功或超时到达。

### 处理死锁

在上述的锁算法中存在一个问题：如果客户端失败、崩溃或者无法释放锁，会发生什么？
由于锁的键包含了一个UNIX时间戳，所以可以检测到这种情况。
如果这样一个时间戳等于当前的Unix时间，那么锁就不再有效。

当发生这种情况时，我们不能只是调用`DEL`来删除锁然后尝试发出`SETNX`，因为这里存在竞争条件，当多个客户端检测到过期的锁并尝试释放时。

* C1 和 C2 读取 `lock.foo` 来检查时间戳，因为它们在执行 `SETNX` 后都收到了 `0`，说明锁仍由在持有锁的 C3 在崩溃后。
* C1 发送 `DEL lock.foo`
* C1 发送 `SETNX lock.foo` 并且成功
* C2 发送 `DEL lock.foo`
* C2 发送 `SETNX lock.foo` 并且成功
* **错误**：由于竞争条件，C1 和 C2 都获取了锁。

庆幸的是，可以通过以下算法避免这个问题。
让我们看看我们的理智客户端C4如何使用好的算法：

* C4发送`SETNX lock.foo`以获取锁定

*   崩溃的客户端C3仍然持有它，因此Redis将回复给C4`0`。

* C4发送`GET lock.foo`来检查锁是否过期。
    如果没有过期，它将睡眠一段时间后重新尝试。

*   相反，如果`lock.foo`处的Unix时间比当前的Unix时间早，则C4尝试执行以下操作：

    ```
    GETSET lock.foo <current Unix timestamp + lock timeout + 1>
    ```

* 因为 `GETSET` 语义，C4 可以检查存储在 `key` 上的旧值是否仍然是一个过期的时间戳。
  如果是，那么锁已经被获取。

*   如果另一个客户端，例如C5，比C4更快并通过`GETSET` 操作获取了锁，则C4的 `GETSET` 操作将返回一个未过期的时间戳。
    C4将简单地重新从第一步开始。
    注意，即使C4在未来的几秒钟内稍微设置了一下这个键也不是一个问题。

为了让这个锁定算法更加健壮，在解锁键值之前，持有锁的客户端应始终检查超时是否过期并使用`DEL`来解锁。因为客户端故障可能是复杂的，不仅可能崩溃，还可能在某些操作上阻塞很长时间，并尝试在很长时间后（当锁已被另一个客户端持有时）执行`DEL`操作。
