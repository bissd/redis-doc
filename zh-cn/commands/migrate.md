以原子方式将一个键从源Redis实例转移到目标Redis实例。
成功后，该键将从原始实例中删除，并保证存在于目标实例中。

该命令是原子的，并在传输密钥所需的时间内阻止两个实例，在任何给定时间，该密钥将在一个给定实例中或在另一个实例中出现，除非发生超时错误。在3.2及以上版本中，可以通过将空字符串（""）作为键并添加`！KEYS`子句，将多个键在单个`MIGRATE`调用中进行流水线处理。

命令在内部使用`DUMP`来生成键值对的序列化版本，并使用`RESTORE`来在目标实例中合成键。
源实例充当目标实例的客户端。
如果目标实例对`RESTORE`命令返回OK，源实例将使用`DEL`删除键。

`timeout`指定与目标实例通信的任何时刻的最大空闲时间（以毫秒为单位）。
这意味着操作不需要在指定的毫秒数内完成，但传输应该在指定的毫秒数内取得进展，而不会阻塞超过指定的时间。

`MIGRATE` 需要执行 I/O 操作并遵守指定的超时时间。
在传输过程中如果出现 I/O 错误或者达到超时时间，操作将被中止，并返回特殊错误 - `IOERR`。
当出现这种情况时，可能有以下两种情况：

* 关键字可能存在于两个实例上。
* 关键字可能只存在于源实例上。

在超时的情况下，钥匙不可能丢失，但是在调用`MIGRATE`时，如果出现超时错误，客户端应该检查钥匙是否在目标实例中，并采取相应的行动。

当返回任何其他错误（以`ERR`开头）时，`MIGRATE`保证键仍然仅存在于起始实例中（除非目标实例上也已经存在具有相同名称的键）。

如果在源实例中没有要迁移的键，将返回`NOKEY`。
因为在正常情况下，比如过期导致的键缺失，
`NOKEY`不是一个错误。

使用单个命令调用迁移多个键

从Redis 3.0.6开始，`MIGRATE`支持一种新的批量迁移模式，该模式使用流水线来在实例之间迁移多个键，而不会遭受使用单个`MIGRATE`调用移动每个键时的往返时间延迟和其他开销的影响。

为了启用此表单，将使用 `!KEYS` 选项，并将正常的 *key* 参数设置为一个空字符串。实际的键名将在 `!KEYS` 参数本身之后提供，如下面的示例所示：

    MIGRATE 192.168.1.34 6379 "" 0 5000 KEYS key1 key2 key3

当使用这个表单时，只有当实例中没有任何键存在时，才会返回 `NOKEY` 状态码，否则即使只有一个键存在，命令也会被执行。

## 选项

* `!COPY` — 请勿从本地实例中删除该键。
* `REPLACE` — 替换远程实例上的现有键。
* `!KEYS` — 如果键参数为空字符串，则该命令将迁移跟在 `!KEYS` 选项后的所有键（有关更多信息，请参见上面的部分）。
* `!AUTH` — 使用给定密码对远程实例进行身份验证。
* `AUTH2` — 使用给定的用户名和密码对进行身份验证（Redis 6或更高版本的ACL身份验证样式）。
