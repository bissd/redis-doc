这个命令只能发送给Redis集群的副本节点，它强制副本节点启动其主实例的手动故障转移。

手动故障切换是一种特殊的故障切换，通常在没有实际故障发生时执行，但我们希望以安全的方式将当前的主节点与其中一个副本（即我们发送命令的节点）进行交换，而不会出现任何数据丢失的窗口。它的工作方式如下：

1. 副本告诉主服务器停止处理来自客户端的查询。
2. 主服务器回复副本当前的*复制偏移量*。
3. 副本等待复制偏移量在自己这一侧匹配，确保在继续之前已经处理了主服务器的所有数据。
4. 副本开始故障转移，从大多数主服务器获取新的配置时期，并广播新的配置。
5. 旧主服务器接收配置更新：解除客户端的阻塞状态，并开始用重定向消息回复，以便它们可以与新的主服务器继续交流。

这种方式可以将客户端原子地从旧主节点移动到新主节点，而且只有在正在转变为新主节点的复制品处理完来自旧主节点的所有复制流之后才能进行。

## FORCE 选项: 当主节点宕机时进行手动故障转移

命令行的行为可以通过两个选项进行修改：**FORCE**和**TAKEOVER**。

如果给出了**FORCE**选项，则副本不会与主服务器进行任何握手，可能无法访问，而是从步骤4开始尽快启动故障转移。当我们希望在主服务器不再可访问时手动启动故障转移时，这是非常有用的。

然而，即使使用**FORCE**，我们仍然需要大多数主节点可用，以授权故障转移并为即将成为主节点的副本生成新的配置时代。

## 采用TAKEOVER选项：手动故障切换而不需要集群一致性

有些情况下这是不够的，我们希望在没有与集群的其他部分达成协议的情况下进行故障切换。
一个真实世界的用例是将不同数据中心的副本批量提升为主节点，
以便在所有主节点都宕机或被隔离的情况下执行数据中心切换。

**TAKEOVER**选项意味着**FORCE**选项所指示的一切，并且不需要任何集群授权来执行故障切换。接收到`CLUSTER FAILOVER TAKEOVER`命令的副本将执行以下操作：

- 一方面，生成一个新的 `configEpoch`，只需获取当前最大的epoch并递增，当本地配置epoch不是最大时。
- 另一方面，将自己分配为master的所有哈希槽，并尽快将新的配置传播给可达的每个节点，最终传播给其他所有节点。

请注意，"TAKEOVER"违反了Redis集群的"最后故障恢复优先原则"，因为副本生成的配置时代违反了正常生成配置时代的几个条件：

1. 不能保证它实际上是更高的配置纪元，因为例如我们可以在少数派中使用**TAKEOVER**选项，也没有进行任何消息交换来生成新的配置纪元。
2. 如果我们生成的配置纪元恰好与另一个实例产生冲突，最终我们的配置纪元或者与我们相同纪元的另一个实例的纪元将会被移开，使用*配置纪元冲突解决算法*。

因此，应谨慎使用**TAKEOVER**选项。

## 实现细节和注意事项

* `CLUSTER FAILOVER`命令在未指定**TAKEOVER**选项的情况下，不会同步执行故障切换。
  它只是*安排*了一个手动故障切换，绕过了故障检测阶段。
* `OK`回复并不保证故障切换将成功。
* 只有在群集中的大多数主节点认可一个副本为副本时，该副本才能被晋升为主节点。
  如果副本是刚刚添加到群集中的新节点（例如升级后添加的），可能还不为群集中的所有主节点所知。
  要检查主节点是否知晓新副本，可以向每个主节点发送`CLUSTER NODES`或`CLUSTER REPLICAS`，并检查其是否出现为副本，然后再向副本发送`CLUSTER FAILOVER`。
* 要验证故障切换实际上已经发生，可以使用`ROLE`、`INFO REPLICATION`（在成功故障切换后会显示“role:master”）或`CLUSTER NODES`，以验证命令发送后群集状态是否发生了变化。
* 要检查故障切换是否失败，请检查副本的日志是否记录了“Manual failover timed out”（如果在几秒钟后副本放弃了故障切换）。
