在字符串中计算设置位的数量（人口计数）。

默认情况下，将检查字符串中包含的所有字节。
可以通过传递额外的参数“开始”和“结束”来指定仅在一个区间内进行计数操作。

像`GETRANGE`命令的开始和结束参数可以包含负值，以便从字符串的末尾开始索引字节，其中-1表示最后一个字节，-2表示倒数第二个字节，以此类推。

不存在的键被视为空字符串，因此命令将返回零。

默认情况下，额外的参数_start_和_end_指定一个字节索引。
我们可以使用额外的参数`BIT`来指定一个位索引。
所以0是第一个位，1是第二个位，依此类推。
对于负值，-1是最后一个位，-2是倒数第二个，以此类推。

@examples

```cli
SET mykey "foobar"
BITCOUNT mykey
BITCOUNT mykey 0 0
BITCOUNT mykey 1 1
BITCOUNT mykey 1 1 BYTE
BITCOUNT mykey 5 30 BIT
```

## 模式：使用位图实时度量

位图是某些类型信息非常空间有效的表示方式。
一个例子是一个 Web 应用程序，它需要用户访问历史记录，以便能够确定哪些用户是测试功能的良好目标。

使用`SETBIT`命令来实现这个问题非常简单，用一个递增的小整数来标识每一天。
例如，第0天是应用程序上线的第一天，第1天是接下来的一天，依此类推。

每次用户执行页面查看操作时，应用程序可以使用 `SETBIT` 命令设置对应于当天的位，注册用户在当天访问网站的信息。

后来，通过调用`BITCOUNT`命令对位图，就能轻松知道用户访问网站的单日次数。

一篇名为"[Fast easy realtime metrics using Redis
bitmaps][hbgc212fermurb]"的文章中描述了一种类似的模式，其中使用用户ID而不是日期。

[hbgc212fermurb]: http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps

## 性能考虑

在上述的计算天数的示例中，即使经过了10年，应用程序仍然在线，每个用户仍然只有`365*10`比特的数据，即每个用户只有456字节的数据。
在这么小的数据量下，`BITCOUNT`命令的速度与其他O(1)级别的Redis命令（如`GET`或`INCR`）一样快速。

当位图很大时，有两种选择：

* 使用一个独立的键来保存位图每次修改时递增的值。这可以通过一个小的Redis Lua脚本来实现非常高效且原子操作。
* 使用`BITCOUNT`命令的`start`和`end`可选参数逐步计算位图，将结果在客户端累加，并可选择将结果缓存到一个键中。
