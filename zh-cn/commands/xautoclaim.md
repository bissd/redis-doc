这个命令将所有满足指定条件的待处理流条目的所有权转移。从概念上讲，`XAUTOCLAIM`等效于调用`XPENDING`，然后调用`XCLAIM`，但是通过`SCAN`类似的语义提供了一种更直接的处理消息传递失败的方式。

就像`XCLAIM`一样，该命令在提供的`<group>`的上下文中操作位于`<key>`的流条目。
它会将所有待处理时间超过`<min-idle-time>`毫秒且ID大于等于`<start>`的消息转移所有权给`<consumer>`。


可选的 `<count>` 参数，默认为 100，是命令尝试获取的条目数量的上限。
在内部，命令从 `<start>` 开始扫描消费者组的待处理条目列表（PEL），并过滤出空闲时间小于或等于 `<min-idle-time>` 的条目。
命令扫描的待处理条目数量的最大值是将 `<count>` 的值乘以 10（硬编码）。
因此，实际获取的条目数量可能少于指定的值。

可选的 `JUSTID` 参数会改变回复，只返回成功认领的消息的ID数组，而不返回实际消息。
使用此选项意味着重试计数器不增加。

该命令将声明的条目作为数组返回。它还返回一个流ID，用作后续调用的`<start>`参数，用于类似游标的用途。
当没有剩余的PEL条目时，该命令将返回特殊的`0-0` ID来表示完成。
但是，请注意，即使扫描完成时，您可能仍然希望继续调用`XAUTOCLAIM`，并使用`0-0`作为`<start>` ID，因为时间过去了足够长，所以较早的待处理条目现在可能有资格进行声明。

请注意，只有空闲时间超过`<min-idle-time>`的消息才会被认领，认领消息会重置其空闲时间。
这确保只有一个消费者可以成功地在某个时刻认领一个特定的待处理消息，并且可以简单地降低处理同一消息多次的概率。

在迭代PEL时，如果`XAUTOCLAIM`遇到一个在流中不存在的消息（被修剪或由`XDEL`删除），它不会声明它，并从找到它的PEL中删除它。此功能在Redis 7.0中引入。
这些消息ID作为`XAUTOCLAIM`的回复的一部分返回给调用者。

最后，使用`XAUTOCLAIM`命令来获取消息也会增加该消息的尝试投递次数，除非使用了`JUSTID`选项（仅投递消息ID而非消息本身）。
无法处理的消息（例如，消费者在处理它们时经常崩溃）会显示出高尝试投递次数，可以通过监控来检测。

@examples

```
> XAUTOCLAIM mystream mygroup Alice 3600000 0-0 COUNT 25
1) "0-0"
2) 1) 1) "1609338752495-0"
      2) 1) "field"
         2) "value"
3) (empty array)
```

在上面的示例中，我们尝试声明自开始流起至少一小时未被确认或声明的待处理和空闲（未被确认或声明的待处理和空闲）的25个条目。
"mygroup" 组的消费者 "Alice" 获得了这些消息的所有权。
需要注意的是，在示例中返回的流ID是`0-0`，表示已经扫描了整个流。
我们还可以看到，`XAUTOCLAIM` 没有遇到任何删除的消息（第三个回复元素是一个空数组）。
