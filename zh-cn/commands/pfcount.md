当以单个键调用时，返回在指定变量中存储的HyperLogLog数据结构计算得出的近似基数，如果变量不存在则为0。

当使用多个键调用时，通过将存储在提供的键处的HyperLogLogs合并到临时HyperLogLog中，返回传递的HyperLogLogs的近似并集的基数。

**超级日志日志（HyperLogLog）**数据结构可以用来仅使用一小部分常量内存来计数集合中的**唯一**元素，每个HyperLogLog具体需要12k字节（加上几个字节用于键本身）。

返回的观察集的基数并不准确，而是用0.81%的标准误差进行近似。

例如，为了统计一天内执行的所有唯一搜索查询的数量，程序需要在处理每个查询时调用`PFADD`。可以随时使用`PFCOUNT`检索估计的唯一查询数量。

注意：调用此函数可能会导致HyperLogLog被修改，因为最后8个字节编码了最新计算的基数，用于缓存目的。因此，`PFCOUNT`在技术上是一个写入命令。


@examples

```cli
PFADD hll foo bar zap
PFADD hll zap zap zap
PFADD hll foo bar
PFCOUNT hll
PFADD some-other-hll 1 2 3
PFCOUNT hll some-other-hll
```

表演

当使用单个键调用`PFCOUNT`时，即使在理论上处理密集HyperLogLog所需的时间很长，性能也非常出色。这是可能的，因为`PFCOUNT`使用缓存来记忆先前计算的基数，这个基数很少改变，因为大多数`PFADD`操作不会更新任何寄存器。每秒可以进行数百次操作。

当使用`PFCOUNT`命令同时传入多个键时，会执行即时合并HyperLogLogs的操作，这个过程较慢。此外，不支持缓存集合的基数并且使用多个键进行`PFCOUNT`操作可能需要数毫秒的时间，因此不宜滥用该命令。

用户应该记住，使用单个按键和多个按键执行此命令在语义上是不同的，性能也不同。

HyperLogLog表示
---


Redis HyperLogLogs 的表示采用双重表示：适用于元素数量较少的 HLL 的 *稀疏* 表示（导致只有少量寄存器设置为非零值），以及适用于较高基数的 *密集* 表示。Redis 在需要时会自动从稀疏表示切换到密集表示。

稀疏表示使用经过优化的运行长度编码，以高效地存储大量被设为零的寄存器。稠密表示是一个 Redis 字符串，大小为 12288 字节，以存储 16384 个 6 位计数器。使用双重表示的原因是，在较小的基数下，仅使用 12k（即稠密表示的内存需求）编码一些寄存器是极其非最优的。

两种表示方法都以16字节的头部为前缀，其中包括一个魔术值、一个编码/版本字段，以及以小端格式存储的缓存的基数估计（如果自从计算基数以来HyperLogLog已更新，则最高有效位为1）。

由于HyperLogLog是Redis字符串，可以使用`GET`命令检索，并使用`SET`命令还原。即使在使用损坏的HyperLogLog时调用`PFADD`、`PFCOUNT`或`PFMERGE`命令也不会出现问题，它可能返回随机值，但不会影响服务器的稳定性。在大多数情况下，当破坏稀疏表示时，服务器会识别破坏并返回错误。

从处理器字长和字节序的角度来看，该表示是中性的，因此32位和64位处理器，大端或小端都使用相同的表示。

有关Redis HyperLogLog实现的更多详细信息可以在[此博文](http://antirez.com/news/75)中找到。在`hyperloglog.c`文件中，实现的源代码也很容易阅读和理解，并包括用于稀疏和稠密表示的精确编码的完整规范。
