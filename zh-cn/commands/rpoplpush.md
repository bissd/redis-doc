以原子操作的方式，返回并移除存储在 `source` 的列表的最后一个元素（尾部），并将该元素推到存储在 `destination` 的列表的第一个元素（头部）。

例如：考虑`source`持有列表`a,b,c`，而`destination`持有列表`x,y,z`。
执行`RPOPLPUSH`会使`source`持有`a,b`，而`destination`持有`c,x,y,z`。

如果`source`不存在，则返回值为`nil`，并且不执行任何操作。

如果`source`和`destination`相同，则操作相当于将列表中的最后一个元素删除，并将其作为列表的第一个元素推入，因此可以将其视为一个列表旋转命令。

@examples

```cli
RPUSH mylist "one"
RPUSH mylist "two"
RPUSH mylist "three"
RPOPLPUSH mylist myotherlist
LRANGE mylist 0 -1
LRANGE myotherlist 0 -1
```

## 模式: 可靠队列

Redis经常被用作消息服务器来实现后台任务处理或其他类型的消息任务。
通常通过将值推入生产者端的列表中来获得简单的队列，并在消费者端使用`RPOP`（使用轮询）或`BRPOP`（如果客户端更适合使用阻塞操作）来等待这些值。

然而，在这种情况下，获取的队列是不可靠的，因为消息有可能会丢失。例如，当存在网络问题或者消费者在接收到消息后但在处理之前崩溃的情况下。

`RPOPLPUSH`（或`BRPOPLPUSH`用于阻塞变体）提供了一种避免此问题的方法：消费者获取消息的同时将其推送到一个“处理中”列表中。
一旦消息被处理完毕，它将使用`LREM`命令将消息从“处理中”列表中移除。

附加客户端可以监视“处理”列表中停留时间过长的项目，如有需要，将超时的项目再次推入队列。

## 模式：循环列表

使用相同的源键和目标键，客户端可以使用`RPOPLPUSH`一次访问一个N个元素列表中的所有元素，而无需使用单个`LRANGE`操作将完整列表从服务器传输到客户端，时间复杂度为 O(N)。

即使出现以下条件中的任意一个或两个，上述模式也可以正常工作：

* 有多个客户端轮流访问列表：它们会提取不同的元素，直到访问完列表的所有元素，并重新开始这个过程。
* 其他客户端正在积极地将新项目推送到列表的末尾。

上述使得实现一个系统变得非常简单，这个系统需要将一组项目以尽可能快的速度连续地由N个工作人员处理。
一个例子是一个监控系统，该系统必须检查一组网站是否可访问，并使用一定数量的并行工作人员以最小延迟的方式进行检查。

注意，这个工人的实现是易于扩展和可靠的，因为即使消息丢失，项目仍然在队列中，并将在下一次迭代中处理。
