`BLPOP`是一个阻塞列表弹出原语。
它是`LPOP`的阻塞版本，当没有任何给定列表中的元素可以弹出时，它会阻塞连接。
从第一个非空列表的头部弹出一个元素，按照给定的顺序检查给定的键。

## 非阻塞行为

当调用`BLPOP`时，如果至少一个指定的键包含一个非空列表，则从列表的头部弹出一个元素并与弹出它的`key`一起返回给调用者。

键按照给定的顺序进行检查。
假设键 `list1` 不存在，而 `list2` 和 `list3` 保存了非空列表。
考虑以下命令：

```
BLPOP list1 list2 list3 0
```

`BLPOP`保证从存储在`list2`中的列表返回一个元素（因为在按顺序检查`list1`、`list2`和`list3`时，它是第一个非空列表）。

## 阻塞行为

如果指定的键都不存在，`BLPOP` 命令会阻塞连接，直到另一个客户端对其中一个键执行 `LPUSH` 或 `RPUSH` 操作为止。

一旦列表中出现新数据，客户端将返回解锁该键的名称和弹出的值。

当`BLPOP`导致客户端阻塞且指定了非零超时时，
如果在指定的超时时间内没有针对至少一个指定的键进行push操作，
客户端将解除阻塞并返回一个`nil`的Multi-Bulk值。

**timeout参数被解释为以秒为单位的双精度值，指定最大阻塞的秒数**。超时为零可用于无限阻塞。

## 哪个按键先服务？哪个客户端？哪个元素？优先顺序细节。

* 如果客户端尝试阻塞多个键，但至少一个键包含元素，则返回的键/元素对是从左到右的第一个具有一个或多个元素的键。在这种情况下，客户端不会被阻塞。因此，例如 `BLPOP key1 key2 key3 key4 0`，假设`key2`和`key4`都不为空，将始终从`key2`返回一个元素。
* 如果多个客户端为同一个键被阻塞，在服务的时候，首先被服务的是等待时间更长的客户端（首个对该键进行阻塞的客户端）。一旦客户端被解除阻塞，它不会保留任何优先级，在下一次调用`BLPOP`时再次阻塞时，将根据已经对同一键进行阻塞的客户端数量进行服务，这些客户端将按阻塞顺序（首先到最后一个阻塞的客户端）进行服务。
* 当客户端同时阻塞多个键，并且在多个键中同时可用元素（由于事务或Lua脚本将元素添加到多个列表），客户端将使用接收到推送操作的第一个键来解除阻塞（假设它有足够的元素为客户端提供服务，因为可能还有其他客户端正在等待此键）。基本上，在执行每个命令之后，Redis将运行接收到数据并且至少有一个客户端被阻塞的所有键的列表。该列表按照新元素到达时间进行排序，从接收到数据的第一个键到最后一个键。对于每个处理的键，Redis将按照FIFO的方式为所有等待该键的客户端提供服务，只要该键中有元素。当键为空或不再有客户端等待该键时，将处理在前一个命令/事务/脚本中接收到新数据的下一个键，依此类推。

当在列表中推入多个元素时，`!BLPOP`命令的行为。

有时候列表可以在同一概念命令的上下文中接收多个元素：

* 可变参数推送操作，例如 `LPUSH mylist a b c`。
* 在对同一列表进行多次推送操作的 `MULTI` 块的 `EXEC` 后。
* 执行 Redis 2.6 或更新版本的 Lua 脚本。

当将多个元素推入一个阻塞的客户端列表中时，在Redis 2.4和Redis 2.6或更新版本中的行为是不同的。

对于Redis 2.6版本，所发生的是执行多次Push的命令，并且只有在命令执行后，才会为被阻塞的客户端提供服务。考虑以下命令序列。

    Client A:   BLPOP foo 0
    Client B:   LPUSH foo a b c

如果发生上述条件，并且使用 Redis 2.6 或更高版本的服务器，客户端 **A** 将被提供 `c` 元素，因为在 `LPUSH` 命令之后，列表包含 `c,b,a`，所以从左边取一个元素意味着返回 `c`。

相反，Redis 2.4 以不同的方式工作：客户端在推送操作的*上下文中*得到服务，因此只要`LPUSH foo a b c`开始将第一个元素推送到列表中，它将会被传递给客户端**A**，客户端**A**将收到`a`（第一个被推送的元素）。

Redis 2.4 的行为在复制或将数据持久化到 AOF 文件时会出现很多问题，因此在 Redis 2.6 中引入了更通用和语义更简单的行为来防止问题的发生。

请注意，出于同样的原因，Lua脚本或者`MULTI/EXEC`块可能会将元素推入一个列表并且之后**删除该列表**。在这种情况下，被阻塞的客户端将无法被提供服务，并且只要在执行单个命令、事务或脚本后列表中没有数据，它们就会继续被阻塞。

在`!MULTI` / `!EXEC`事务中使用`!BLPOP`

`BLPOP`可以与流水线一起使用（发送多个命令并批量读取回复），但这种设置几乎只有在它是流水线的最后一个命令时才有意义。

在`MULTI` / `EXEC`块内使用`BLPOP`并没有太多意义，因为它需要阻塞整个服务器以便原子化执行块，这样就不允许其他客户端执行推送操作。因此，当列表为空时，`BLPOP`在`MULTI` / `EXEC`内的行为是返回一个`nil`的多个批量回复，这与超时到达时的情况相同。

如果你喜欢科幻，想象一下在`MULTI` / `EXEC` 块内部时间以无限速度流动...

@examples

```
redis> DEL list1 list2
(integer) 0
redis> RPUSH list1 a b c
(integer) 3
redis> BLPOP list1 list2 0
1) "list1"
2) "a"
```

## 可靠队列

当`BLPOP`将一个元素返回给客户端时，它也会从列表中删除该元素。这意味着元素只存在于客户端的上下文中：如果客户端在处理返回的元素时崩溃，那么元素将永远丢失。

这可能是一些应用程序中的问题，我们希望有一个更可靠的消息系统。在这种情况下，请检查`BRPOPLPUSH`命令，它是`BLPOP`的一种变体，在将返回的元素返回给客户端之前，将其添加到目标列表中。

## 模式：事件通知

使用阻塞列表操作，可以挂载不同的阻塞原语。
例如，对于某些应用程序，您可能需要阻塞等待Redis Set中的元素，这样只要向Set添加一个新元素，就可以在不使用轮询的情况下检索它。
这将需要一个不可用的阻塞版本的`SPOP`，但是使用阻塞列表操作，我们可以轻松完成这个任务。

消费者将会进行以下操作：

```
LOOP forever
    WHILE SPOP(key) returns elements
        ... process elements ...
    END
    BRPOP helper_key
END
```

在生产者端，我们只需要简单地使用：

```
MULTI
SADD key element
LPUSH helper_key x
EXEC
```
