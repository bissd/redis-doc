命令行的行为如下：

* 如果存在滞后于复制的副本：
  * 通过执行 `CLIENT PAUSE` 命令，并使用 `WRITE` 选项来暂停试图写入的客户端。
  * 等待配置的 `shutdown-timeout`（默认为10秒），使副本追上复制偏移量。
* 停止所有客户端。
* 如果配置了至少一个保存点，则执行阻塞式保存（blocking SAVE）。
* 如果启用了AOF（Append Only File），则刷新AOF文件。
* 退出服务器。

如果启用了持久性，此命令将确保Redis关闭而不丢失任何数据。

注意：未配置持久化到磁盘的 Redis 实例（没有 AOF 配置，也没有 "save" 指令）将不会在 `SHUTDOWN` 时转储 RDB 文件，因为通常你不希望 Redis 实例仅用于缓存时在关闭时阻塞。

另外请注意：如果Redis接收到`SIGTERM`和`SIGINT`信号中的任意一个，将执行相同的关闭序列。
另请参阅[信号处理](/topics/signals)。

## 修饰符

可以指定可选的修饰符来改变命令的行为。
具体来说：

* **SAVE** 将强制进行数据库保存操作，即使没有配置任何保存点。
* **NOSAVE** 将阻止数据库保存操作，即使配置了一个或多个保存点。
* **NOW** 跳过等待滞后副本，即绕过关闭序列中的第一步。
* **FORCE** 忽略通常会阻止服务器退出的任何错误。
  有关详细信息，请参见下一节。
* **ABORT** 取消正在进行的关闭操作，不能与其他标志组合使用。

## SHUTDOWN 失败的条件

当配置了保存点或指定了SAVE修饰符时，如果无法保存RDB文件，关机可能会失败。
然后，服务器将继续运行以确保没有数据丢失。
使用FORCE修饰符可以绕过此操作，强制服务器退出。

当启用追加模式文件时，关闭可能会失败，因为系统处于不允许立即安全持久化到磁盘的状态。

通常情况下，如果有一个AOF子进程正在执行AOF重写，Redis会简单地杀死它并退出。
然而，有些情况下这样做是不安全的，除非指定了**FORCE**修改器，否则**SHUTDOWN**命令将被拒绝并报错。
下面是发生这种情况的情形：

* 用户刚刚打开了AOF功能，服务器触发了第一次AOF重写以创建初始AOF文件。在这种情况下，停止将会导致全部数据集的丢失：一旦重新启动，服务器可能会启用AOF，但没有任何AOF文件。
* 如果一个启用了AOF的副本重新连接到它的主服务器，并进行了完全重新同步，并重新启动AOF文件，触发初始AOF创建过程。在这种情况下，如果不能完成AOF重写，会导致从主服务器接收到的最新数据集的丢失。新的主服务器实际上可以是另一个实例（如果使用了**REPLICAOF**或**SLAVEOF**命令来重新配置副本），因此完成AOF重写并从正确的数据集开始非常重要，以表示服务器终止时内存中的数据集。

有时候，我们只想尽快终止一个 Redis 实例，而不管它的内容是什么。
在这种情况下，可以使用命令 **SHUTDOWN NOW NOSAVE FORCE** 。
在 7.0 版本之前，**NOW** 和 **FORCE** 标志不可用，正确的命令组合是发送 **CONFIG appendonly no** ，然后是 **SHUTDOWN NOSAVE**。
第一个命令将关闭需要的 AOF，并终止其重写子进程（如果存在）。
第二个命令执行时将没有问题，因为 AOF 不再启用。

## 最小化数据丢失的风险

自 Redis 7.0 版本开始，在关闭之前，服务器会等待落后的副本达到可配置的 `shutdown-timeout`，默认为10秒。
这样可以尽最大努力减少在未配置保存点且禁用了 AOF 的情况下发生数据丢失的风险。
在7.0版本之前，在没有磁盘的设置下关闭 heavily loaded 的主节点更有可能导致数据丢失。
为了在这种设置中最小化数据丢失的风险，在关闭主节点之前，建议手动触发 `FAILOVER`（或 `CLUSTER FAILOVER`）将主节点降级为副本，并提升其中一个副本为新的主节点。

## 行为变化历史

* `>= 7.0.0`：在退出之前引入等待滞后副本。
