这条命令会阻塞当前客户端，直到该客户端之前所有的写入命令被确认已经同步到本地Redis的AOF以及至少指定数量的副本。如果达到了以毫秒为单位的超时时间，即使没有达到指定数量的确认，命令也会返回。

命令将始终返回在当前客户端发送`WAITAOF`命令之前，已将所有写命令进行fsync同步的主节点和副本的数量，无论指定的阈值是否已达到，还是超时时间已到。

一些备注：

1. 当`WAITAOF`返回时，可以保证当前连接上发送的所有先前的写命令都已经被同步到至少`WAITAOF`返回的主节点和从节点的AOF中。
2. 如果该命令作为`MULTI`事务（或任何其他不允许阻塞的上下文，例如脚本内部）的一部分发送，该命令不会阻塞，而是立即返回已将所有先前的写命令同步的主节点和从节点的数量。
3. 超时时间为0意味着永久阻塞。
4. 由于在成功和超时的情况下`WAITAOF`都会返回已完成的fsync数量，客户端应该检查返回的值是否等于或大于所需的持久化水平。
5. 不能在从节点实例上使用`WAITAOF`，如果本地Redis没有启用AOF，则`numlocal`参数不能为非零。

限制
---
可以编写一个模块或Lua脚本，使其将写操作传播到AOF，但不传播到复制流。
（对于模块，可以使用`RedisModule_Call`或`RedisModule_Replicate`的`fmt`参数来实现；对于Lua脚本，可以使用`redis.set_repl`来实现。）

这些功能与当前实现的`WAITAOF`命令不兼容，在组合使用时可能导致不正确的行为。

一致性和WAITAOF
---

请注意，与`WAIT`类似，`WAITAOF`并不能使Redis成为一个强一致性存储。
除非等待整个集群中的所有成员将写入磁盘进行fsync操作，否则在故障切换或Redis重启期间仍然可能丢失数据。
然而，`WAITAOF`确实可以提高实际场景中的数据安全性。

实施细节
---

自Redis 7.2版本起, 即使没有配置副本 (只要AOF存在), Redis也会跟踪和增加复制偏移量。

此外，Redis 备份异步地通过两个复制偏移量向其主服务器发送 ping：它们在复制流中已处理的偏移量，以及它们已将数据同步到 AOF 的偏移量。

对于每个客户端，Redis会记录在执行最后一条写命令时所产生的复制流的复制偏移量。
当调用`WAITAOF`时，Redis会检查本地Redis和/或指定数量的副本是否已确认将该偏移量或更大的偏移量同步到它们的AOF。

@examples

```
> SET foo bar
OK
> WAITAOF 1 0 0
1) (integer) 1
2) (integer) 0
> WAITAOF 0 1 1000
1) (integer) 1
2) (integer) 0
```

在上面的示例中，对`WAITAOF`的第一次调用不使用超时，并要求将写入的内容仅同步到本地Redis；当这一操作完成时，它会返回[1, 0]。

在第二次尝试中，我们指定了一个超时时间，并要求写入被一个副本确认为已同步。
由于没有连接的副本，`WAITAOF`命令在一秒后解除阻塞，并再次返回[1, 0]，表示写入已在本地Redis上进行了fsync操作，但没有副本。
