---
title: 使用Redis Cluster进行扩展
linkTitle: 基于Redis Cluster的扩展
weight: 6
description: 水平扩展Redis Cluster
aliases: [
    /topics/cluster-tutorial,
    /topics/partitioning,
    /docs/manual/scaling,
    /docs/manual/scaling.md
]
---

Redis使用一种名为Redis Cluster的部署拓扑来实现水平扩展。
本主题将教您如何在生产环境中设置、测试和运营Redis Cluster。
您将从最终用户的角度了解Redis Cluster的可用性和一致性特性。

如果您计划运行一个生产环境的 Redis Cluster 部署，或者想更好地了解 Redis Cluster 的内部工作原理，请参考[Redis Cluster 规范](/topics/cluster-spec)。要了解 Redis Enterprise 是如何处理扩展的，请参阅[Redis Enterprise 的线性扩展](https://redis.com/redis-enterprise/technology/linear-scaling-redis-enterprise/)。

## Redis集群101

Redis Cluster 提供一种在多个 Redis 节点之间自动分片的方式来运行 Redis 安装。在分区期间，Redis Cluster 还提供一定程度的可用性，实际上就是当一些节点失败或无法通信时仍能继续操作的能力。但是，在发生更大规模的故障时（例如，大多数主节点不可用），集群将变得不可用。

因此，使用Redis Cluster，您可以获得以下功能：

将您的数据集自动分割为多个节点。
在部分节点发生故障或无法与集群的其余部分通信时，继续进行操作。

#### Redis 集群 TCP 端口

每个 Redis 集群节点都需要两个打开的 TCP 连接：一个 Redis TCP 端口用于为客户端提供服务，例如 6379，以及第二个称为 _cluster bus port_ 的端口。
默认情况下，_cluster bus port_ 是通过将数据端口加上 10000 来设置的（例如，16379）；但是，您可以在 `cluster-port` 配置中覆盖此设置。

集群总线是一种节点到节点的通信渠道，它使用二进制协议，
由于带宽和处理时间较少，更适合节点之间交换信息。
节点使用集群总线进行故障检测、配置更新、故障转移授权等等。
客户端不应尝试与集群总线端口通信，而应使用 Redis 命令端口。
但是，请确保在防火墙中同时开放这两个端口，否则 Redis 集群节点无法通信。

为了使Redis集群正常工作，每个节点都需要以下内容：

1. 与客户端进行通信的客户交互端口（通常为6379），用于与需要访问集群的所有客户端进行通信，以及用于键迁移的所有其他集群节点使用的客户端端口。
2. 集群总线端口必须能够从所有其他集群节点中访问。

如果您不打开TCP端口，您的集群将无法按预期工作。

#### Redis集群和Docker

当前，Redis Cluster不支持NAT环境，也不支持IP地址或TCP端口被重新映射的环境。

Docker使用一种称为“端口映射”的技术：在Docker容器内运行的程序可以通过不同的端口暴露，与程序所认为使用的端口不同。
这对于在同一服务器上同时运行使用相同端口的多个容器非常有用。

为了使Docker与Redis Cluster兼容，您需要使用Docker的_host网络模式_。
有关更多信息，请参阅[Docker文档](https://docs.docker.com/engine/userguide/networking/dockernetworks/)中的`--net=host`选项。

#### Redis 集群数据分片

Redis集群不使用一致性哈希算法，而是使用一种不同的分片方法，其中每个键从概念上讲都属于我们称之为**哈希槽**的一部分。

在Redis集群中有16384个哈希槽，为了计算给定键的哈希槽，我们简单地将键的CRC16取模16384。

在Redis Cluster中，每个节点负责一部分哈希槽。举个例子，你可以有一个包含3个节点的集群，如下所示：

* 节点 A 包含散列槽从 0 到 5500。
* 节点 B 包含散列槽从 5501 到 11000。
* 节点 C 包含散列槽从 11001 到 16383。

让添加和移除集群节点变得容易。例如，如果我想添加一个新的节点D，我需要将一些哈希槽从节点A、B、C移动到D。同样地，如果我想从集群中移除节点A，我只需将由A提供的哈希槽移动到B和C即可。一旦节点A为空，我就可以将其完全从集群中移除。

将散列槽从一个节点移动到另一个节点不需要停止任何操作；因此，添加和删除节点，或更改节点持有的散列槽百分比，不需要停机时间。

Redis Cluster支持多个键操作，只要所有涉及到的键在单个命令执行（或整个事务或Lua脚本执行）中都属于相同的哈希槽。用户可以使用一种称为*哈希标签*的功能来强制多个键成为同一个哈希槽的一部分。

哈希标签在 Redis 集群规范中有记录，但要点是，如果在键中的 {} 括号之间存在子字符串，只有字符串内部的内容会被哈希。例如，键 `user:{123}:profile` 和 `user:{123}:account` 由于共享相同的哈希标签，所以保证位于同一个哈希槽中。因此，您可以在同一多键操作中操作这两个键。

#### Redis集群主从模型

为了在一部分主节点故障或无法与大多数节点通信时继续可用，Redis Cluster 使用主从模型，其中每个哈希槽具有从 1（主节点本身）到 N 个副本（N-1 个额外的副本节点）。

在我们的示例集群中，节点 A、B、C，如果节点 B 失败，集群将无法继续运行，因为我们无法再为哈希槽 5501-11000 提供服务的方式。

然而，在创建集群时（或稍后），我们为每个主节点添加一个副本节点，以便最终集群由A、B、C作为主节点，A1、B1、C1作为副本节点组成。
这样，如果B节点失败，系统可以继续运行。

Node B1 复制 B ，如果 B 失败，集群将提升 B1 为新的主节点，并且将继续正常运行。

请注意，如果节点B和B1同时发生故障，Redis集群将无法继续运行。

#### Redis 集群一致性保证

Redis Cluster不能保证强一致性。在实际操作中，这意味着在某些情况下，Redis Cluster可能会丢失向客户端确认的写操作。

Redis 集群丧失写入的第一个原因是它使用异步复制。这意味着在写入期间会发生以下情况：

* 您的客户端向主节点 B 写入数据。
* 主节点 B 向您的客户端回复 OK。
* 主节点 B 将写操作传播到其副本节点 B1、B2 和 B3。

正如您所看到的，B在回复给客户端之前并不会等待B1、B2、B3的确认，因为这将导致Redis承受无法接受的延迟惩罚。因此，如果您的客户端写入了一些数据，B会确认写入操作，但在将写入操作发送给其副本之前崩溃，其中一个副本（未收到写入操作的副本）可以被提升为主节点，导致该写入操作永远丢失。

这与大多数配置为每秒将数据刷新到磁盘的数据库发生的情况非常相似，因此这是一个您已经能够通过过去使用传统数据库系统而产生的经验进行推理的场景。同样，您可以通过强制数据库在回复客户端之前将数据刷新到磁盘来提高一致性，但这通常会导致性能急剧下降。在Redis Cluster中，这相当于同步复制。

基本上，性能和一致性之间存在权衡。

Redis Cluster在必要时提供同步写入支持，通过`WAIT`命令实现。这使得写入丢失的可能性大大降低。然而，需要注意的是，即使使用同步复制，Redis Cluster也不实现强一致性：在更复杂的故障场景下，仍然有可能选择未能接收写入的副本作为主节点。

有另一个值得注意的情况，Redis Cluster会丢失写入，这种情况发生在一个客户端与包括至少一个主节点的少数实例隔离的网络分区期间。

以一个由A、B、C、A1、B1、C1组成的6个节点集群为例，其中有3个主节点和3个副本。还有一个客户端，我们称之为Z1。

在分区发生后，可能会在其中一边有A、C、A1、B1、C1，而在另一边有B和Z1。

Z1 仍然能够向 B 写入数据，B 将接受它的写入。如果分区在很短的时间内恢复，集群将继续正常运行。然而，如果分区持续足够长的时间，使得 B1 在分区的大多数一侧被提升为主节点，那么 Z1 在此期间发送到 B 的写入将会丢失。

{{% alert title="Note" color="info" %}}
Z1向B发送的写入数量**有限制**：如果足够的时间已经过去，使分区的多数侧选择了一个副本作为主节点，那么少数侧中的所有主节点将停止接受写入操作。
{{% /alert %}}

这个时间量是Redis Cluster的一个非常重要的配置指令，称为**节点超时**。

在节点超时后，主节点被视为失败，并可以由其副本之一替换。
类似地，在节点超时后，如果没有主节点能够感知到大部分其他主节点，它将进入错误状态并停止接受写入操作。

## Redis 集群配置参数

我们即将创建一个示例集群部署。
在继续之前，让我们介绍Redis集群在`redis.conf`文件中引入的配置参数。

* **cluster-enabled `<yes/no>`**: 如果是yes，则在特定的Redis实例中启用Redis集群支持。否则，实例将像通常一样以独立实例的形式启动。
* **cluster-config-file `<filename>`**: 值得注意的是，尽管这个选项的名称是这样的，但它并不是一个可供用户编辑的配置文件，而是Redis集群节点在每次有变化时自动持久化集群配置（基本上是状态），以便在启动时重新读取。该文件列出了集群中其他节点、它们的状态、持久化变量等等。通常情况下，此文件会因为某些消息接收导致被重新编写并刷新到磁盘上。
* **cluster-node-timeout `<milliseconds>`**: Redis集群节点在没有被视为故障的情况下可不可用的最长时间。如果一个主节点在超过指定的时间内无法访问，其将由其从节点进行故障转移。该参数还控制Redis集群的其他重要事项。特别地，如果在指定时间内无法与大部分主节点建立连接的节点，将停止接受查询。
* **cluster-slave-validity-factor `<factor>`**: 如果设置为0，则从节点将始终被视为有效，因此无论主节点和从节点之间的连接断开时间有多长，从节点都会尝试故障转移主节点。如果值为正数，则最大断开时间计算为*节点超时*乘以此选项提供的因子，如果节点是从节点，并且主节点的连接断开时间超过指定的时间，则从节点将不会尝试启动故障转移。例如，如果将节点超时设置为5秒，并且将有效性因子设置为10，则从主节点断开链接超过50秒的从节点将不会尝试故障转移其主节点。请注意，任何与零不同的值可能导致主节点故障后Redis集群不可用，如果没有能够进行故障转移的从节点。在这种情况下，只有原始主节点重新加入集群后，集群才会恢复可用状态。
* **cluster-migration-barrier `<count>`**: 主节点将保持与其他多少个从节点连接，以便另一个不再有任何从节点覆盖的主节点进行从节点迁移。有关更多信息，请参阅本教程中关于从节点迁移的适当章节。
* **cluster-require-full-coverage `<yes/no>`**: 如果设置为yes（默认情况下是yes），当一定百分比的键空间未被任何节点覆盖时，集群将停止接受写入。如果将此选项设置为no，则即使只能处理一部分键的请求，集群仍将处理查询。
* **cluster-allow-reads-when-down `<yes/no>`**: 如果设置为no（默认情况下是no），当Redis集群被标记为失败时，Redis集群中的节点将停止提供所有流量，无论是节点无法达到大多数主节点还是无法满足完全覆盖要求。这样可以防止从不了解集群中的更改的节点读取潜在的不一致数据。可以将此选项设置为yes，以允许在故障状态下从节点进行读取，这对于希望优先保障读取可用性但仍希望防止不一致写入的应用程序非常有用。当只有一个或两个分片时，也可以使用它来使用Redis集群，因为它允许节点在主节点故障但无法进行自动故障转移时继续提供写入服务。

## 创建和使用 Redis 集群

要创建和使用Redis集群，请按照以下步骤进行操作：

* [创建 Redis 集群](#创建-redis-集群)
* [与集群互动](#与集群互动)
* [使用 redis-rb-cluster 编写示例应用](#使用-redis-rb-cluster-编写示例应用)
* [重分配集群](#重分配集群)
* [一个更有趣的示例应用](#一个更有趣的示例应用)
* [测试故障切换](#测试故障切换)
* [手动故障切换](#手动故障切换)
* [添加新节点](#添加新节点)
* [删除节点](#删除节点)
* [副本迁移](#副本迁移)
* [升级 Redis 集群节点](#升级-redis-集群节点)
* [迁移到 Redis 集群](#迁移到-redis-集群)

但是，请先了解创建集群的要求。

#### 创建一个 Redis Cluster 的要求

要创建一个集群，首先需要运行一些空的 Redis 实例，并以 _集群模式_ 运行。

请在 `redis.conf` 文件中至少设置以下指令：

```
port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
```

要启用集群模式，请将 `cluster-enabled` 指令设置为 `yes`。
每个实例还包含一个文件路径，该路径用于存储此节点的配置，默认为 `nodes.conf`。
此文件不会被人为操作，它只是在 Redis 集群实例启动时生成，并在需要时进行更新。

请注意，以预期方式正常工作的**最小集群**必须包含至少三个主节点。对于部署，我们强烈推荐一个由三个主节点和三个副本组成的六节点集群。

你可以在本地测试这个功能，通过在任意给定的目录下创建以实例的端口号命名的以下目录。

例如：

```
mkdir cluster-test
cd cluster-test
mkdir 7000 7001 7002 7003 7004 7005
```

在7000至7005的每个目录中创建一个`redis.conf`文件。
将上面的小例子作为配置文件的模板，但请确保将端口号`7000`替换为正确的端口号，根据目录名称而定。


您可以按照以下方式启动每个实例，每个实例在单独的终端标签中运行：

```
cd 7000
redis-server ./redis.conf
```
您将会从日志中看到，每个节点都会为自己分配一个新的ID：

    [82462] 26 Nov 11:56:55.329 * No cluster configuration found, I'm 97a3a64667477371c4479320d683e4c8db5858b1

这个ID将永久被此特定实例使用，以便实例在集群环境中拥有唯一的名称。每个节点使用这些ID来记住其他节点，而不是使用IP地址或端口。IP地址和端口可能会改变，但是唯一的节点标识符将在节点的整个生命周期中保持不变。我们简单地称之为**节点ID**。

#### 创建一个Redis集群

既然我们有一些正在运行的实例，你需要通过向节点编写一些有意义的配置来创建你的集群。

您可以手动配置和执行单个实例，也可以使用create-cluster脚本。
让我们来学习一下手动操作的过程。

要创建集群，请运行以下命令：

    redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \
    127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \
    --cluster-replicas 1

这里使用的命令是 **create**，因为我们想要创建一个新的集群。
选项 `--cluster-replicas 1` 表示我们希望为每个主节点创建一个副本。

其他参数是我想要使用创建新集群的实例的地址列表。

`redis-cli` 将提供一份配置。通过键入 **yes** 来接受建议的配置。

集群将被配置和*加入*，这意味着实例将启动并开始相互通信。最后，如果一切顺利，您将看到一条类似如下的消息：

    [OK] All 16384 slots covered

这意味着每个16384个可用槽位都至少有一个主实例提供服务。

如果您不想通过上述配置和执行单个实例来创建Redis集群，有一个更简单的系统（但您将无法了解相同数量的操作细节）。

在Redis分发中找到`utils/create-cluster`目录。
里面有一个名为`create-cluster`的脚本(与包含它的目录同名)，它是一个简单的bash脚本。为了启动一个包含3个主节点和3个从节点的6个节点集群，只需输入以下命令：

1. `创建集群开始`
2. `创建集群创建`

在第2步中，当`redis-cli`工具要求您接受集群布局时，请回复`yes`。

现在您可以与集群进行交互，第一个节点默认将在端口30001上启动。完成后，可以使用以下命令停止集群：

### 3. `create-cluster stop`

请阅读此目录中的`README`文件以获取有关如何运行脚本的更多信息。

#### 与集群交互

要连接到Redis集群，您需要一个能够支持集群的Redis客户端。
请参考您选择的客户端的[文档](/docs/clients)，以确定其是否支持集群。

您还可以使用`redis-cli`命令行工具来测试您的Redis集群：

```
$ redis-cli -c -p 7000
redis 127.0.0.1:7000> set foo bar
-> Redirected to slot [12182] located at 127.0.0.1:7002
OK
redis 127.0.0.1:7002> set hello world
-> Redirected to slot [866] located at 127.0.0.1:7000
OK
redis 127.0.0.1:7000> get foo
-> Redirected to slot [12182] located at 127.0.0.1:7002
"bar"
redis 127.0.0.1:7002> get hello
-> Redirected to slot [866] located at 127.0.0.1:7000
"world"
```

{{% alert title="Note" color="info" %}}
如果您使用脚本创建集群，您的节点可能会在不同的端口上监听，默认从30001开始。
{{% /alert %}}

`redis-cli`集群支持非常基础，它总是利用Redis集群节点能够将客户端重定向到正确的节点。
一个严谨的客户端能够做得更好，它可以缓存哈希槽和节点地址之间的映射关系，直接使用正确的连接访问正确的节点。
这个映射关系只在集群配置发生变化时进行刷新，例如故障转移后或者系统管理员通过添加或删除节点来修改集群布局后。

#### 使用redis-rb-cluster编写示例应用程序

在展示如何操作Redis Cluster之前，进行故障转移或重分片之类的操作，我们需要创建一些示例应用或至少能够理解简单Redis Cluster客户端交互的语义。

以这种方式，我们可以运行一个示例，并同时尝试使节点发生故障，或者启动重新分片，以观察Redis Cluster在真实世界条件下的行为。在没有任何写操作到集群时，观察它的运作并不是很有帮助。

该部分介绍了[redis-rb-cluster](https://github.com/antirez/redis-rb-cluster)的一些基本用法，展示了两个示例。
第一个示例如下，位于redis-rb-cluster发行版中的[`example.rb`](https://github.com/antirez/redis-rb-cluster/blob/master/example.rb)文件中：

```
   1  require './cluster'
   2
   3  if ARGV.length != 2
   4      startup_nodes = [
   5          {:host => "127.0.0.1", :port => 7000},
   6          {:host => "127.0.0.1", :port => 7001}
   7      ]
   8  else
   9      startup_nodes = [
  10          {:host => ARGV[0], :port => ARGV[1].to_i}
  11      ]
  12  end
  13
  14  rc = RedisCluster.new(startup_nodes,32,:timeout => 0.1)
  15
  16  last = false
  17
  18  while not last
  19      begin
  20          last = rc.get("__last__")
  21          last = 0 if !last
  22      rescue => e
  23          puts "error #{e.to_s}"
  24          sleep 1
  25      end
  26  end
  27
  28  ((last.to_i+1)..1000000000).each{|x|
  29      begin
  30          rc.set("foo#{x}",x)
  31          puts rc.get("foo#{x}")
  32          rc.set("__last__",x)
  33      rescue => e
  34          puts "error #{e.to_s}"
  35      end
  36      sleep 0.1
  37  }
```

该应用程序做的事情非常简单，它将形式为 `foo<number>` 的键设置为 `number`，按顺序逐个进行设置。因此，如果您运行该程序，结果将是以下命令流：

* SET foo0 0
* SET foo1 1
* SET foo2 2
* 等等...

这个程序看起来比通常应该复杂，因为它设计为在屏幕上显示错误，而不是通过异常退出，所以每个对集群执行的操作都用`begin` `rescue`块封装。

程序的第14行是第一个有趣的行。它创建了Redis Cluster对象，使用一个*启动节点*列表作为参数，以及此对象可以建立与不同节点的最大连接数，并且在给定操作失败后的超时时间。

启动节点不需要是集群的所有节点。重要的是至少有一个节点可以连接。另外请注意，当redis-rb-cluster能够与第一个节点建立连接后，它会立即更新启动节点列表。您应该对任何其他正式客户端都有这样的行为期望。

由于我们已经将Redis集群对象实例存储在**rc**变量中，
我们可以像正常的Redis对象实例一样使用这个对象。

这正是在**第18至26行**发生的情况：当我们重新启动示例时，我们不希望从`foo0`重新开始，所以我们将计数器存储在Redis中。上面的代码旨在读取此计数器，或者如果计数器不存在，则将其赋值为零。

然而请注意，这是一个while循环，因为我们希望无论集群是否正常工作并返回错误，都可以重试。普通的应用程序并不需要如此谨慎。

**第28至37行之间的代码**开始了主循环，其中设置了键或显示了错误。

注意循环结尾的`sleep`调用。在测试中，如果你想尽可能快地向集群写入数据（相对于这是一个没有真正并行性的繁忙循环，所以你会在最好的情况下获得通常的每秒10k个操作），可以删除这个睡眠调用。

通常为了让人类更容易理解示例应用程序，写操作会变慢。

启动应用程序会产生以下输出：

```
ruby ./example.rb
1
2
3
4
5
6
7
8
9
^C (I stopped the program here)
```

这不是一个很有趣的程序，我们马上就会使用一个更好的程序，但是我们已经可以看到在程序运行时发生的重新分片过程了。

#### 重新分配集群资源

现在我们已经准备好尝试集群重分片。为了做到这一点，请保持 example.rb 程序运行，这样您就可以看到程序运行是否受到一些影响。此外，您可能希望注释掉 `sleep` 调用，在重分片期间增加一些更严重的写入负载。

\#\#\# Resharding 的基本意思是将一组节点的哈希槽迁移至另一组节点。
与创建集群类似，它是通过使用 redis-cli 工具来完成的。

开始resharding，只需键入：

    redis-cli --cluster reshard 127.0.0.1:7000

您只需要指定一个节点，redis-cli 将自动找到其他节点。

当前的redis-cli只能在管理员支持下进行resharding,
你不能简单地说将5%的槽移动到另一个节点(尽管这很简单就可以实现)。
因此，问题开始出现。第一个问题是你想进行多少个resharding:

    How many slots do you want to move (from 1 to 16384)?

我们可以尝试重新分配1000个哈希槽，如果示例仍在运行而不需要休眠调用，则这些槽应该已经包含大量键。

然后，redis-cli需要知道resharding的目标，也就是将接收哈希槽的节点。
我将使用第一个主节点，即127.0.0.1:7000，但我需要指定实例的节点ID。这已经被redis-cli打印在列表中了，但如果需要，我可以始终使用以下命令找到节点的ID：

```
$ redis-cli -p 7000 cluster nodes | grep myself
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460
```

好的，所以我的目标节点是97a3a64667477371c4479320d683e4c8db5858b1。

现在将会询问您要从哪些节点获取这些密钥。
我将输入`all`以从所有其他主节点中获取一些散列槽位。

在最终确认后，您将会看到一个有关每个插槽由redis-cli从一个节点移动到另一个节点的消息，并且每当实际的键从一侧移动到另一侧，都会打印一个点。

在resharding正在进行中时，您应该能够看到您的示例程序正常运行。在resharding期间，您可以随时停止和重新启动它。

在resharding结束时，您可以使用以下命令测试集群的健康状况：

    redis-cli --cluster check 127.0.0.1:7000

所有的插槽将按照惯例被覆盖，但是这次在127.0.0.1:7000的主节点将拥有更多的哈希插槽，大约6461个。

重新分片可以自动执行，无需手动以交互方式输入参数。可以使用以下命令行实现：

    redis-cli --cluster reshard <host>:<port> --cluster-from <node-id> --cluster-to <node-id> --cluster-slots <number of slots> --cluster-yes

这样可以在可能经常进行reshard的情况下构建一些自动机制，
但是目前`redis-cli`没有自动重新平衡集群、检查集群节点间键的分布，
并根据需要智能地移动槽位的方法。这个功能将来会被添加进来。

`--cluster-yes` 选项告诉集群管理器自动回答命令提示的“是”，从而允许它以非交互模式运行。
注意，这个选项也可以通过设置 `REDISCLI_CLUSTER_YES` 环境变量来激活。

#### 一个更有趣的示例应用程序

我们早期编写的示例应用程序并不是很好。
它以一种简单的方式写入集群，甚至没有检查所写的内容是否正确。

从我们的角度来看，接收写入的集群可以将键`foo`始终写入每个操作的`42`，我们完全不会注意到。

在`redis-rb-cluster`存储库中，有一个更有趣的应用程序，名为`consistency-test.rb`。它使用一组计数器，默认情况下是1000，并发送`INCR`命令以增加计数器的值。

不过，应用程序除了仅仅进行写操作外，还有两个额外的功能：

* 当使用`INCR`更新计数器时，应用程序会记住写入。
* 它还在每次写入之前读取一个随机计数器，并检查其值是否与我们在内存中预期的值相匹配。

这意味着该应用程序是一个简单的**一致性检查器**，能够告诉您集群是否丢失了某些写入，或者是否接受了我们没有收到确认的写入。在第一种情况下，我们将看到一个计数器的值比我们记住的值小，而在第二种情况下，该值将更大。

运行一致性测试应用程序会每秒产生一行输出：

```
$ ruby consistency-test.rb
925 R (0 err) | 925 W (0 err) |
5030 R (0 err) | 5030 W (0 err) |
9261 R (0 err) | 9261 W (0 err) |
13517 R (0 err) | 13517 W (0 err) |
17780 R (0 err) | 17780 W (0 err) |
22025 R (0 err) | 22025 W (0 err) |
25818 R (0 err) | 25818 W (0 err) |
```

线显示了执行的**R**读取和**W**写入的数量，以及错误的数量（由于系统不可用而导致查询不被接受的错误）。

如果发现一些不一致，输出结果中会添加新的行。
例如，如果在程序运行时手动重置计数器，会出现以下情况：

```
$ redis-cli -h 127.0.0.1 -p 7000 set key_217 0
OK

(in the other tab I see...)

94774 R (0 err) | 94774 W (0 err) |
98821 R (0 err) | 98821 W (0 err) |
102886 R (0 err) | 102886 W (0 err) | 114 lost |
107046 R (0 err) | 107046 W (0 err) | 114 lost |
```

当我将计数器设置为0时，实际值为114，因此程序报告丢失了114个写入（集群中未被记住的`INCR`命令）。

这个程序作为一个测试用例更加有趣，所以我们将使用它来测试Redis Cluster故障转移。

#### 测试故障转移

为了触发故障转移，我们可以做的最简单的事情（也是分布式系统中语义上最简单的故障）就是崩溃一个单独的进程，我们的情况下是一个单独的主节点。

{{% alert title="Note" color="info" %}}
在进行此测试时，您应该保持打开一个选项卡，并运行一致性测试应用程序。
{{% /alert %}}

我们可以使用以下命令来识别一个主节点并使其崩溃：

```
$ redis-cli -p 7000 cluster nodes | grep master
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422
```

好的，所以7000、7001和7002是主节点。让我们使用**DEBUG SEGFAULT**命令来使节点7002崩溃：

```
$ redis-cli -p 7002 debug segfault
Error: Server closed the connection
```

现在我们可以查看一致性测试的输出，看看它报告了什么。

```
18849 R (0 err) | 18849 W (0 err) |
23151 R (0 err) | 23151 W (0 err) |
27302 R (0 err) | 27302 W (0 err) |

... many error warnings here ...

29659 R (578 err) | 29660 W (577 err) |
33749 R (578 err) | 33750 W (577 err) |
37918 R (578 err) | 37919 W (577 err) |
42077 R (578 err) | 42078 W (577 err) |
```

正如您在故障转移过程中所看到的，系统无法接受578个读取和577个写入请求，但数据库中没有出现不一致的情况。这可能听起来出乎意料，因为在本教程的前部分，我们提到Redis集群在故障转移过程中可能会丢失写入请求，因为它使用异步复制。我们没有说的是，这种情况发生的可能性非常小，因为Redis几乎同时将回复发送给客户端和要复制给副本的命令，因此数据丢失的窗口非常小。然而，很难触发并不意味着不可能发生，所以这并不改变Redis集群所提供的一致性保证。

我们现在可以检查故障转移后的集群设置（请注意，期间我重新启动了崩溃的实例，使其作为副本重新加入集群）：

```
$ redis-cli -p 7000 cluster nodes
3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected
a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422
3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected
```

现在主节点分别运行在端口7000、7001和7005上。之前在端口7002上运行的主节点现在是7005的副本。

`CLUSTER NODES` 命令的输出看起来可能令人生畏，但实际上非常简单，由以下标记组成：

* 节点ID
* IP地址:端口
* 标志: 主节点、副本、本节点、失败，...
* 如果是副本，则为主节点的节点ID
* 上次等待回复的待处理PING时间。
* 上次收到的PONG时间。
* 该节点的配置纪元（详见集群规范）。
* 与该节点的连接状态。
* 所服务的槽位...

#### 手动故障转移

有时候强制故障切换是有用的，而实际上并没有引起主节点的任何问题。
例如，升级其中一个主节点的Redis进程时，最好将其故障切换为一个副本，以最小化可用性的影响。

Redis Cluster 支持手动故障转移，可以使用 `CLUSTER FAILOVER` 命令在想要进行故障转移的主节点的其中一个从节点上执行。

手动故障转移是特殊的，与实际主节点故障引起的故障转移相比更安全。它们通过在系统确保新的主节点已处理完旧主节点的所有复制流之后，仅将客户端从原始主节点切换到新的主节点，以避免数据丢失的方式进行。

在执行手动故障切换时，您可以在副本日志中看到以下内容：

# 用户请求手动故障转移已接受。
# 收到停止复制的主服务器手动故障转移的复制偏移量: 347540
# 所有主复制流程已处理完毕，可以开始手动切换。
选举的开始延迟了0毫秒（排名＃0，偏移量347540）。
# 启动故障转移选举，选举周期为7545。
# Failover选举成功：我是新的主节点。

基本上，与我们执行故障转移的主服务器连接的客户端会停止运行。
同时，主服务器会将其复制偏移量发送给等待达到偏移量的副本。
当达到复制偏移量时，故障转移开始，并告知旧的主服务器切换配置。
当在旧的主服务器上取消阻塞客户端时，它们将被重定向到新的主服务器。

{{% alert title="Note" color="info" %}}
要将复制品提升为主节点，它必须首先被集群中大多数的主节点认识为复制品。
否则，它无法获得故障切换选举的胜利。
如果复制品刚刚被添加到集群中（参见【将新节点添加为复制品】(#add-a-new-node-as-a-replica)），在发送 `CLUSTER FAILOVER` 命令之前，您可能需要等待一段时间，以确保集群中的主节点确切知道这个新的复制品。
{{% /alert  %}}

### 添加一个新节点

添加一个新节点基本上就是添加一个空节点，然后将一些数据移入其中，如果它是一个新的主节点的话，或者告诉它设置成一个已知节点的复制品，如果它是一个复制节点的话。

我们将展示两种情况，首先是添加一个新的主实例。

无论哪种情况，首先需要执行的步骤是**添加一个空节点**。

这就像在端口7006上启动一个新节点一样简单（我们已经在现有的六个节点中使用了从7000到7005的端口），使用与其他节点相同的配置，除了端口号之外，所以您应该做的是遵循我们用于之前节点的设置：

* 在您的终端应用程序中创建一个新的标签页。
* 进入`cluster-test`目录。
* 创建一个名为`7006`的目录。
* 在里面创建一个redis.conf文件，类似于其他节点使用的配置，但使用7006作为端口号。
* 最后使用 `../redis-server ./redis.conf` 启动服务器。

在这一点上，服务器应该正在运行。

现在我们可以像往常一样使用**redis-cli**来向现有集群中添加节点。

    redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000

正如您所看到的，我使用了 **add-node** 命令，将新节点的地址作为第一个参数指定，并将群集中的一个随机现有节点的地址作为第二个参数。

从实际角度来看，redis-cli在这里几乎没有对我们有什么帮助，它只是向节点发送了一个"CLUSTER MEET"的消息，而这也是可以手动完成的。然而，redis-cli还会在执行操作之前检查集群的状态，因此即使你知道内部工作原理，始终通过redis-cli执行集群操作也是一个好主意。

现在我们可以连接到新节点上，看看它是否真的加入了集群：

```
redis 127.0.0.1:7006> cluster nodes
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921
3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected
f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected
a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected
97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422
3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383
```

请注意，由于该节点已经连接到集群，它已经能够正确地重定向客户端查询，并且通常是集群的一部分。但是与其他主节点相比，它有两个特殊之处：

* 它没有分配哈希槽，因此没有存储任何数据。
* 由于它是一个没有分配槽的主节点，当一个复制节点想要成为主节点时，它不参与选举过程。

现在可以使用`redis-cli`的resharding功能将哈希槽指派给该节点。
基本上没有必要显示这个，因为我们已经在上一节中做过了，没有什么区别，只是一个以空节点为目标的resharding。

##### 添加一个新节点作为副本

有两种方法可以添加新的副本。显而易见的一种方法是再次使用redis-cli工具，但加上--cluster-slave选项，如下所示：

    redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave

请注意，此处的命令行与我们用于添加新主节点的命令行完全相同，因此我们没有指定要将副本添加到哪个主节点。在这种情况下，redis-cli将把新节点添加为拥有更少副本的主节点之一的副本。

然而，您可以使用以下命令行指定要使用的主节点创建新副本。

    redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e

这样我们将新的副本分配给特定的主服务器。

以更加手动的方式向特定主节点添加副本的方法是将新节点添加为一个空的主节点，然后使用`CLUSTER REPLICATE`命令将其转换为副本。如果节点被添加为一个副本但希望将其移动为不同主节点的副本，该方法同样适用。

例如，为了为当前在 范围11423-16383 中服务哈希槽的节点 127.0.0.1:7005 添加一个副本，其节点 ID 为 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e，我所需要做的就是连接新节点（已作为空主节点）并发送以下命令：

    redis 127.0.0.1:7006> cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e

就是这样。现在我们为这组哈希槽创建了一个新的副本，集群中的所有其他节点已经知道了（在更新配置所需的几秒钟之后）。我们可以使用以下命令验证：

```
$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected
```

现在节点 3c3a0c... 有两个副本，分别运行在端口 7002（现有的）和 7006（新的）。

#### 删除一个节点

要删除一个副本节点，只需使用redis-cli的`del-node`命令：

    redis-cli --cluster del-node 127.0.0.1:7000 `<node-id>`

第一个参数只是集群中的一个随机节点，第二个参数是您想要移除的节点的 ID。

您可以以同样的方式删除主节点，但是为了删除主节点，**它必须是空的**。如果主节点不为空，则需要将数据从主节点重新分配到所有其他主节点。

另一种删除主节点的方法是手动将其故障转移为其副本之一，然后在其成为新主节点的副本后删除该节点。显然，当您想要减少集群中实际的主节点数量时，这并没有帮助，这种情况下需要进行重新分片。

#### 复制品迁移

在Redis Cluster中，您可以随时使用以下命令重新配置副本以与不同的主节点进行复制：

    CLUSTER REPLICATE <master-node-id>

然而，有一种特殊情况，你希望副本在没有系统管理员帮助的情况下自动从一个主节点迁移到另一个主节点。副本的自动重新配置被称为*副本迁移*，能够提高Redis集群的可靠性。

{{% alert title="Note" color="info" %}}
你可以在[Redis Cluster Specification](/topics/cluster-spec)中阅读关于副本迁移的详细信息，这里我们只提供一些关于一般思路和如何从中受益的信息。
{{% /alert %}}

让集群副本在某些条件下从一个主节点移动到另一个主节点的原因是，通常情况下，Redis 集群对故障的抵抗力与附加到给定主节点的副本数量一样强大。

例如，如果每个主节点都有一个副本的集群，在主节点和副本同时发生故障的情况下，无法继续运行，原因是没有其他实例能够拥有主节点正在提供的哈希槽的副本。然而，虽然网络分裂可能会同时孤立多个节点，但许多其他类型的故障，如硬件或软件故障，局限于单个节点，属于一类非常显著的故障，不太可能同时发生。因此，在每个主节点都有一个副本的集群中，副本可能在凌晨4点被杀死，主节点可能在早上6点被杀死。这仍将导致集群无法继续运行。

为了提高系统的可靠性，我们有添加额外副本到每个主节点的选项，但这是昂贵的。副本迁移允许只向少数主节点添加更多副本。因此，您有10个主节点，每个节点有1个副本，总共20个实例。然而，您可以添加例如3个实例作为某些主节点的副本，因此某些主节点将拥有不止一个副本。

通过副本迁移，如果主节点没有副本，则从具有多个副本的主节点中迁移一个副本到被“孤立”的主节点。所以在上面的示例中，当你的副本在凌晨4点停机时，另一个副本会取而代之。当主节点在上午5点也发生故障时，仍然存在一个可以选举的副本，以使集群能够继续运行。

那么，简而言之，关于副本迁移，您应该了解些什么呢？

* 集群将尝试从当前拥有最多副本的主节点中迁移一个副本。
* 要从副本迁移中获益，您只需向集群中的任一主节点添加几个更多的副本即可，不必考虑是哪个主节点。
* 有一个配置参数用于控制副本迁移功能，名为 `cluster-migration-barrier`：您可以在 Redis Cluster 提供的示例 `redis.conf` 文件中了解更多信息。

#### 升级 Redis 集群中的节点

升级副本节点非常简单，只需要停止节点并使用更新版本的Redis重新启动即可。如果有客户端在使用副本节点进行读取扩展，它们应该能够在某个副本不可用时重新连接到另一个副本。

升级主控节点比较复杂，建议的步骤是：

1.使用`CLUSTER FAILOVER`命令将主节点手动切换到其中一个副本节点。
（请参阅本主题中的[手动切换](#手动切换)部分。）
2.等待主节点变成副本节点。
3.最后按照副本节点的方式升级节点。
4.如果您希望升级后的节点成为主节点，请触发新的手动切换以将升级后的节点重新转换为主节点。

根据以下步骤，您应该逐个升级节点，直到所有节点都升级完成。

#### 迁移到Redis集群

对于愿意迁移到 Redis 集群的用户来说，他们可能只有一个主节点，或者可能已经在使用预先存在的分片设置，其中键被分配到 N 个节点上，使用某种内部算法或由客户端库或 Redis 代理实现的分片算法。

无论哪种情况，都可以轻松使用Redis Cluster进行迁移。然而，最重要的细节是应用程序如何使用多键操作。有三种不同情况：

1. 不使用多键操作、事务或涉及多个键的Lua脚本。键是独立访问的（即使通过将多个命令组合到事务或Lua脚本中以访问同一个键）。
2. 使用多个键操作、事务或涉及多个键的Lua脚本，但只有具有相同**哈希标签**的键才会被使用，这意味着一起使用的键都具有完全相同的`{...}`子字符串。例如，在相同哈希标签的上下文中定义了以下多键操作：`SUNION {user:1000}.foo {user:1000}.bar`。
3. 使用与具有明确或相同哈希标签的键名不同的键名的多键操作、事务或涉及多个键的Lua脚本。

第三种情况不被Redis集群处理：应用程序需要修改以不使用多键操作，或者只在相同哈希标记的上下文中使用它们。

第1和第2个案例已经涉及到了，所以我们将重点关注这两个案例，它们的处理方式是相同的，因此在文档中不会进行区分。

假设你的现有数据集已经划分为N个主节点，其中
如果你没有之前的分片,N = 1，则需要执行以下步骤
为了将数据集迁移到Redis Cluster：

1. 停止您的客户端。目前不能自动将实例迁移到Redis Cluster。您可以在应用程序/环境的上下文中编排实现实时迁移。
2. 使用`BGREWRITEAOF`命令为您的N个主节点生成一个追加日志文件，并等待AOF文件完全生成。
3. 将AOF文件从aof-1保存到aof-N的某个位置。在此时，如果希望可以停止旧的实例（在非虚拟化部署中，通常需要重复使用相同的计算机）。
4. 创建一个由N个主节点和零个副本组成的Redis Cluster。稍后将添加副本。确保所有节点都使用追加日志文件进行持久化。
5. 停止所有集群节点，使用现有的追加日志文件替换它们的追加日志文件，将aof-1替换为第一个节点的文件，以此类推，直到aof-N。
6. 使用新的AOF文件重新启动Redis Cluster节点。根据其配置，他们将报告那些不应该存在的键。
7. 使用`redis-cli --cluster fix`命令修复集群，以便键根据每个节点的哈希槽迁移权限进行迁移。
8. 最后使用`redis-cli --cluster check`命令检查您的集群是否正常。
9. 重新启动已修改为使用Redis Cluster感知的客户端库的客户端。

有一种替代方案可以将数据从外部实例导入到 Redis 集群中，就是使用 `redis-cli --cluster import` 命令。

该命令将运行实例的所有键（从源实例中删除键）移动到指定的预先存在的 Redis Cluster。然而，请注意，如果您使用 Redis 2.8 实例作为源实例，操作可能会很慢，因为2.8版本不实现迁移连接缓存，所以您可能希望在执行此操作之前使用 Redis 3.x 版本重启源实例。

{{% alert title="Note" color="info" %}}
从Redis 5开始，如果不考虑向后兼容性，Redis项目不再使用"slave"一词。不幸的是，在此命令中，"slave"一词是协议的一部分，因此只有当此API被自然废弃时，我们才能删除此类出现。
{{% /alert %}}

## 了解更多

* [Redis Cluster 规范](/topics/cluster-spec)
* [使用 Redis Enterprise 实现线性扩展](https://redis.com/redis-enterprise/technology/linear-scaling-redis-enterprise/)
* [Docker 文档](https://docs.docker.com/engine/userguide/networking/dockernetworks/)

