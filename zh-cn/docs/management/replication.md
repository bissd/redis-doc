---
title: Redis复制
linkTitle: 复制
weight: 5
description: Redis如何通过复制实现高可用性和故障转移
aliases: [
    /topics/replication,
    /topics/replication.md,
    /docs/manual/replication,
    /docs/manual/replication.md
]
---

在 Redis 复制的基础上（不包括由 Redis Cluster 或 Redis Sentinel 提供的高可用性特性），存在着一种简单易用且易配置的主从复制（leader follower）机制。它允许副本 Redis 实例成为主实例的精确副本。无论主实例发生什么情况，副本都会在每次链接中断后自动重新连接到主实例，并尝试成为其精确副本。

这个系统使用三种主要机制工作：

1. 当主节点和副本实例连接良好时，主节点通过向副本发送命令流来保持副本的更新，以复制因客户端写入、键过期或驱逐以及其他更改主数据集引起的数据集变化的效果。

2. 当主节点和副本之间的连接断开，可能是由于网络问题或主节点或副本检测到超时，副本将重新连接并尝试进行部分重新同步：这意味着它将尝试仅获取在断开连接期间错过的命令流部分。

3. 当无法进行部分重新同步时，副本将请求进行全面重新同步。这将涉及更复杂的过程，其中主节点需要创建其所有数据的快照，将其发送给副本，然后在数据集更改时继续发送命令流。

Redis默认使用异步复制，低延迟且高性能，这是大多数Redis使用场景的自然复制模式。但是，Redis副本会定期异步确认它们接收到的数据量。因此，主节点无需每次都等待副本处理完命令，但是如果需要的话，它会知道哪个副本已经处理了哪个命令。这样可以实现可选的同步复制。

客户端可以使用`WAIT`命令来请求对某些数据进行同步复制。然而，`WAIT`只能确保在其他Redis实例中有指定数量的确认副本，它不能将一组Redis实例转变为具有强一致性的CP系统：在故障转移期间，已确认的写操作仍然可能丢失，这取决于Redis持久性的具体配置。然而，使用`WAIT`命令后，写操作在失败事件后丢失的概率大大降低，只有在某些难以触发故障模式下才会丢失。

您可以查阅Redis Sentinel或Redis Cluster文档以获取更多关于高可用性和故障转移的信息。本文档的其余部分主要描述了Redis基本复制的基本特性。

### Redis复制的重要事实

* Redis使用异步复制，带有异步从副本到主机的数据处理确认。
* 主服务器可以拥有多个副本。
* 副本能够接受来自其他副本的连接。除了将多个副本连接到同一个主机，副本还可以以级联结构连接到其他副本。自Redis 4.0以来，所有子副本将从主服务器接收到完全相同的复制流。
* Redis复制在主服务器端是非阻塞的。这意味着当一个或多个副本执行初始同步或部分重新同步时，主服务器将继续处理查询请求。
* 复制在副本侧也基本上是非阻塞的。当副本执行初始同步时，它可以使用旧版本的数据集来处理查询，假设您在redis.conf中配置了Redis以这样做。否则，您可以配置Redis副本，在复制流关闭时向客户端返回错误。然而，在初始同步之后，必须删除旧的数据集并加载新的数据集。在此短暂窗口期间（对于非常大的数据集，可能长达几秒），副本将阻止进入的连接。自Redis 4.0以来，您可以将Redis配置为在一个不同的线程中删除旧数据集，然而加载新的初始数据集仍将在主线程中进行，并且将阻塞副本。
* 复制既可以用于扩展性，为只读查询拥有多个副本（例如，可以将耗时的O(N)操作转移到副本中），也可以用于提高数据安全性和高可用性。
* 您可以使用复制来避免主服务器将完整数据集写入磁盘的成本：一种典型的技术是将主服务器的`redis.conf`配置为根本不保存到磁盘，然后连接一个定期保存或启用AOF的副本。然而，这种设置必须小心处理，因为重新启动的主服务器将以空数据集开始：如果复制尝试与其同步，副本也将被清空。

当主服务器持久性关闭时，复制的安全性

在使用Redis复制的设置中，强烈建议在主服务器和副本中打开持久化。如果由于非常慢的磁盘导致延迟问题，无法进行持久化，那么实例应该被配置为在重启后**避免自动重启**。

为了更好地理解为什么关闭持久性的主服务器配置为自动重启是危险的，请查看以下故障模式，其中数据被从主服务器及其所有副本中清除：

1. 我们有一个设置，其中节点 A 充当主节点，关闭了持久化功能，而节点 B 和节点 C 从节点 A 复制数据。
2. 节点 A 崩溃了，但它有一些自动重启系统，可以重启进程。然而，由于关闭了持久化功能，节点重新启动时数据集为空。
3. 节点 B 和节点 C 将从空的节点 A 复制数据，因此它们将有效地销毁自己的数据副本。

当使用Redis Sentinel实现高可用性时，同时关闭主节点的持久化且自动重新启动进程是危险的。例如，主节点可能重新启动得足够快，以至于Sentinel无法检测到故障，导致上述描述的故障模式发生。

每当数据安全重要时，使用没有持久化配置的主节点进行复制时，应禁用实例的自动重启功能。

## Redis复制工作原理

每个Redis主节点都有一个复制ID：它是一个大型伪随机字符串，用于标记数据集的特定状态。每个主节点还会取一个偏移量，用于增加每个复制流的字节，以便将其发送给副本，从而使用新的更改来更新副本的状态，以修改数据集。即使实际上没有连接任何副本，复制偏移量也会增加，因此实际上每个给定的一对：

    Replication ID, offset

标识主数据集的确切版本。

当副本连接到主节点时，它们使用`PSYNC`命令发送它们旧的主节点复制ID和到目前为止处理的偏移量。这样主节点可以只发送所需的增量部分。然而，如果主节点缓冲区中没有足够的*后备记录*，或者副本引用的历史（复制ID）已不再存在，那么将进行完全重新同步：在这种情况下，副本将从头开始获取数据集的完整副本。

这是完全同步的详细工作原理：

主节点启动后台保存过程以产生一个RDB文件。同时，它开始缓冲所有接收到的新写命令。当后台保存完成后，主节点将数据库文件传输给从节点，从节点将其保存到磁盘上，然后加载到内存中。然后，主节点将所有缓冲的命令发送给从节点。这些命令以Redis协议本身的格式作为命令流进行传输。

您可以通过telnet自行尝试。在服务器执行某些操作时，连接到Redis端口并发出`SYNC`命令。您将看到一个批量传输，然后主服务器接收到的每个命令都会在telnet会话中重新执行。实际上，`SYNC`是一种旧的协议，新的Redis实例不再使用它，但为了向后兼容仍然存在：它不允许部分重新同步，因此现在使用`PSYNC`代替。

如前所述，当主副本链接出现问题时，副本能够自动重新连接。如果主节点接收到多个并发的副本同步请求，它将执行一次后台保存，以便为所有请求提供服务。

## 复制 ID 解释

在前面的章节中，我们提到如果两个实例具有相同的复制ID和复制偏移量，那么它们具有完全相同的数据。然而，了解复制ID的确切含义以及为什么实际上有两个复制ID（主ID和次要ID）是很有用的。

一个复制ID基本上标记了数据集的一个给定的*历史*。每当一个实例从头开始作为主服务器重新启动，或者一个副本被提升为主服务器，都会为该实例生成一个新的复制ID。与主服务器连接的副本在握手之后会继承其复制ID。因此，具有相同ID的两个实例通过它们持有相同的数据，但可能在不同的时间持有。偏移量作为一个逻辑时间，用于理解在给定的历史（复制ID）中，谁持有最新的数据集。

例如，如果两个实例A和B具有相同的复制ID，但一个偏移量为1000，另一个偏移量为1023，这意味着第一个实例缺少应用于数据集的某些命令。这也意味着通过应用只有少量命令，实例A可以达到与实例B完全相同的状态。

Redis实例具有两个复制ID的原因是因为被提升为主服务器的副本。在故障切换之后，提升为主服务器的副本需要记住其过去的复制ID，因为这样的复制ID是前任主服务器的复制ID。这样，当其他副本与新主服务器进行同步时，它们将尝试使用旧的主服务器复制ID执行部分重新同步。这将按预期工作，因为当副本被提升为主服务器时，它将将其副本ID设置为其主ID，并记住此ID切换发生时的偏移量。然后，它将选择一个新的随机复制ID，因为新的历史开始了。在处理新连接的副本时，主服务器将将它们的ID和偏移量与当前ID和副本ID进行匹配（为了安全起见，偏移量限制在一定范围内）。简而言之，这意味着在故障切换后，连接到新晋主服务器的副本无需执行完整同步。

在副本升级为主服务器后为何需要更改它的复制ID，可能是因为旧主服务器仍然作为主服务器工作，原因是由于某些网络分区的存在。保留相同的复制ID将违反相同ID和相同偏移量意味着两个随机实例具有相 同数据集的事实。

## 无盘复制

通常，完整的重新同步需要在磁盘上创建一个RDB文件，然后从磁盘重新加载相同的RDB以向副本提供数据。

慢磁盘上的这个操作可能对主机来说是一个非常有压力的操作。
Redis版本2.8.18是第一个支持无磁盘复制的版本。
在这种设置中，子进程直接将RDB通过网络发送给副本，而不使用磁盘作为中间存储。

## 配置

配置基本的Redis复制是微不足道的：只需将以下行添加到副本配置文件中：

    replicaof 192.168.1.1 6379

当然，您需要将192.168.1.1 6379替换为您的主节点IP地址（或
主机名）和端口。或者，您可以调用`REPLICAOF`命令，
主机将开始与副本进行同步。

在内存中，主节点还有一些用于调整复制后备的参数，用于执行部分重新同步。有关更多信息，请参见Redis发布的“redis.conf”示例。

可通过启用`repl-diskless-sync`配置参数来启用无盘复制。在第一个副本到达后，等待更多副本到达开始传输的延迟由`repl-diskless-sync-delay`参数控制。有关更多详细信息，请参考Redis发行版中的示例`redis.conf`文件。

## 只读副本

自从Redis 2.6版本以来，副本支持默认启用的只读模式。
这种行为受redis.conf文件中的`replica-read-only`选项控制，可以使用`CONFIG SET`在运行时启用和禁用。

只读副本将拒绝所有写入指令，因此不可能因为错误而写入副本。但这并不意味着该功能旨在将副本实例暴露给互联网或更广泛的存在不受信任的客户端的网络，因为诸如`DEBUG`或`CONFIG`的管理指令仍然可用。请参阅[安全](/topics/security)页面了解如何保护 Redis 实例。

你可能想知道为什么可以恢复只读设置，并且可以有可写副本实例用于写操作的目标。答案是可写副本仅出于历史原因而存在。使用可写副本可能导致主数据库和副本数据库之间不一致，因此不建议使用可写副本。要了解在哪些情况下这可能是个问题，我们需要了解复制工作的原理。主数据库上的更改通过将普通的Redis命令传播到副本来进行复制。当主数据库上的键过期时，会传播一个DEL命令。如果在主数据库上存在某个键，但是在副本数据库中已被删除、过期或具有与主数据库不同的类型，它对于来自主数据库传播的DEL、INCR或RPOP等命令会产生不同的反应。传播的命令可能在副本上失败，或者产生不同的结果。要尽量减少风险（如果您坚持使用可写副本），我们建议您遵循以下建议：

* 不要在可写副本上写入与主服务器上已使用的键相同的键。
  （如果您无法控制写入主服务器的所有客户端，这可能很难保证。）

* 在运行中的系统中，当升级一组实例时，不要将实例配置为可写副本作为中间步骤。
  常规情况下，如果想要保证数据一致性，不要将实例配置为可写副本，如果它可以被提升为主服务器。

# 历史上，有一些使用情况被认为是合理的可写副本的用例。
# 从7.0版本开始，这些用例现在已经过时，可以通过其他方式实现相同的效果。
# 例如：

* 通过使用像 `SUNION` 和 `ZINTER` 这样返回结果而不存储的命令，来计算缓慢的集合或排序集合操作，并将结果存储在临时本地键中，而不是使用 `SUNIONSTORE` 和 `ZINTERSTORE` 命令。

* 使用`SORT`命令（由于可选的STORE选项，该命令不被视为只读命令，因此不能在只读副本上使用）。
  而是使用`SORT_RO`命令，这是一个只读命令。

* 使用`EVAL`和`EVALSHA`也不被视为只读命令，因为Lua脚本可能调用写入命令。
  反之，使用`EVAL_RO`和`EVALSHA_RO`，在Lua脚本中只能调用只读命令。

尽管副本与主节点重新同步或副本重新启动时会丢弃写入的数据，但不能保证它们会自动同步。

在4.0版本之前，可写副本无法根据设置的生存时间来过期键。
这意味着，如果您使用`EXPIRE`或其他设置键的最大生存时间的命令，键将会泄漏。虽然您可能无法通过读取命令访问到键，但它仍然会在键的计数中出现，并且仍然会使用内存。
Redis 4.0 RC3及更高版本能够像主节点一样驱逐具有TTL的键，但DB编号大于63的键除外（不过默认情况下，Redis实例只有16个数据库）。
但请注意，即使在高于4.0的版本中，对可能存在于主节点上的键使用`EXPIRE`也会导致副本和主节点之间的不一致。

另外请注意，Redis 4.0起，复制写操作仅本地执行，并不会传播到连接到该实例的子级副本。相反，子级副本将始终接收与顶级主节点发送给中间副本的复制流完全相同的流。因此，例如在以下设置中：

    A ---> B ---> C

即使 `B` 是可写的，`C` 也无法看到 `B` 的写入，而是拥有与主实例 `A` 完全相同的数据集。

## 将副本设置为验证主节点

如果您的主节点通过`requirepass`设置了密码，那么在所有的同步操作中配置副本使用该密码是很简单的。

要在运行中的实例上执行此操作，请使用 `redis-cli` 并输入：

    config set masterauth <password>

要永久设置，请将以下内容添加到您的配置文件中：

    masterauth <password>

## 只允许带有 N 个附属副本的写入

从Redis 2.8开始，您可以配置Redis主节点，仅当至少N个副本当前连接到主节点时，才接受写入查询。

然而，由于Redis使用异步复制，无法确保复制品是否实际接收到了给定的写入操作，因此始终存在数据丢失的风险。

功能的工作方式如下：

* Redis副本每秒钟向主服务器发送ping请求，确认复制流处理的数量。
* Redis主服务器会记住每个副本最后一次接收到ping的时间。
* 用户可以配置最小数量的延迟不大于指定秒数的副本数。

如果至少有N个复制品，并且滞后时间不超过M秒，那么写入将被接受。

您可以将其视为一种尽力保护数据安全的机制，其中对于给定的写入操作不保证一致性，但至少数据丢失的时间窗口被限制在给定的秒数内。总体上，有界的数据丢失比无界的数据丢失要好。

如果不满足条件，主机将以错误回复，并且写入将不被接受。

这个功能有两个配置参数：

* min-replicas-to-write `<副本数>`
* min-replicas-max-lag `<秒数>`

有关更多信息，请查看随 Redis 源发行版附带的示例`redis.conf`文件。

## 如何处理 Redis 复制中的过期键

当一个 Redis 主节点过期了一个键之后，他会在 AOF 文件或者 RDB 快照中记录一个 DEL 命令，以此来告知从节点删除相应的键。从节点会等待主节点将 DEL 命令传送给它，并执行相应操作，删除对应的键。这样从节点可以保持和主节点一致的状态。

当一个键过期之后，主节点会将带有该键的 DEL 命令传输给从节点，从节点接收到 DEL 命令后会立即删除该键。

然而，在以下情况下，主节点并不会传输 DEL 命令给从节点：

1. 从节点目前处于断线重连的状态。
2. 复制的过程中主节点和从节点的连接断开。
3. 复制的过程中主节点同时有进程崩溃或者重新启动。

在这些情况下，主节点无法将 DEL 命令传送给从节点。当从节点恢复连接或者复制过程结束后，从节点会向主节点发送一个 PSYNC 命令，请求将丢失的数据补上。主节点在收到 PSYNC 命令后，会将缺失的 DEL 命令发送给从节点，从而实现数据的同步。

Redis过期功能允许键具有有限的生存时间（TTL）。这种功能取决于实例计时的能力，然而Redis副本可以正确地复制具有过期时间的键，即使这些键是通过Lua脚本进行更改的。

为了实现这样的功能，Redis不能依赖主从服务器具有同步的时钟，因为这是一个无法解决的问题，会导致竞争条件和数据集的不一致，所以Redis使用了三种主要技术来实现过期键的复制工作：

1. 副本不会使键过期，而是等待主节点使键过期。当主节点使一个键过期（或由于LRU将其驱逐）时，它会合成一个`DEL`命令并传输给所有副本。
2. 由于主节点驱动的过期机制，有时候副本可能仍然在内存中保存着已经逻辑上过期的键，因为主节点不能及时提供`DEL`命令。为了处理这个问题，副本使用它的逻辑时钟来报告一个键在**只读操作**中不存在，这些操作不会违反数据集的一致性（因为新的命令从主节点会到达）。通过这种方式，副本避免了报告仍然存在的逻辑上过期的键。实际上，在使用副本进行扩展的HTML片段缓存中，将避免返回已经超过期望生存时间的项目。
3. 在Lua脚本执行期间，不会执行键的过期操作。当Lua脚本运行时，主节点的时间在概念上被冻结，因此给定的键在脚本运行的整个过程中要么存在要么不存在。这样可以防止脚本执行过程中键的过期，同时也需要以一种能够保证数据集产生相同效果的方式将相同的脚本发送给副本。

一旦一个副本被晋升为主节点，它将开始独立地过期键，并且不再需要来自其旧主节点的任何帮助。

## 在Docker和NAT中配置复制任务

当使用Docker或其他类型的容器进行端口转发或网络地址转换时，Redis复制需要额外注意，尤其是在使用Redis Sentinel或其他需要通过扫描主节点的`INFO`或`ROLE`命令输出来发现从节点地址的系统中。

问题在于`ROLE`命令和`INFO`输出的复制部分，当在主实例中执行时，会显示副本的IP地址，这个IP地址是副本用于连接主实例的地址，而在使用网络地址转换（NAT）的环境中，这个地址可能与副本实例的逻辑地址（客户端应该用于连接副本的地址）不同。

同样，副本将按照配置在`redis.conf`中的监听端口进行列出，该端口可能与转发的端口不同，这取决于端口是否被重新映射。

要解决这两个问题是可能的，自从Redis 3.2.2开始，可以强制一个副本向主节点宣布任意的IP和端口对。要使用的两个配置指令是：

    replica-announce-ip 5.5.5.5
    replica-announce-port 1234

这些参数在最近的Redis发行版示例`redis.conf`中有详细说明。

## INFO和ROLE命令

以下是当前主节点和从节点实例的复制参数的两个Redis命令。一个是`INFO`命令。如果使用`INFO replication`参数调用该命令，只会显示与复制相关的信息。另一个更适合计算机使用的命令是`ROLE`，它提供了主节点和从节点的复制状态，复制偏移量、已连接从节点列表等信息。

## 在重新启动和故障转移后进行部分同步

自 Redis 4.0 版本起，当一个实例在故障转移后被晋升为主节点时，
它仍然能够与之前主节点的副本进行部分重新同步。为了实现这一点，
副本会记住先前主节点的旧复制 ID 和偏移量，因此即使其他副本请求旧的复制 ID，
它也能够向连接的副本提供一部分日志。

然而，提升的副本的新复制ID将会不同，因为它构成了一个不同的数据集历史。例如，主节点可以继续返回可用状态，并在一段时间内继续接受写入，因此在提升的副本中使用相同的复制ID将违反一个复制ID和偏移量对只能标识一个数据集的规则。

此外，当副本被轻松关闭并重新启动时，能够将与其主服务器重新同步所需的信息存储在 `RDB` 文件中。这在升级时非常有用。在需要此操作时，最好使用 `SHUTDOWN` 命令来执行 `保存并退出` 操作。

不可能通过AOF文件部分同步重新启动的副本。然而，实例在关闭之前可以转换为RDB持久性，然后可以重新启动，最后再启用AOF。

在副本上的`Maxmemory`

默认情况下，副本将忽略 `maxmemory`（除非在故障切换后或手动提升为主服务器）。
这意味着键的驱逐将由主服务器处理，将 DEL 命令发送给副本以在主服务器端进行键的驱逐。

这种行为确保了主服务器和副本服务器保持一致，这通常是您想要的。
然而，如果您的副本服务器是可写的，或者您希望副本服务器具有不同的内存设置，并且您确信对副本所执行的所有写操作是幂等的，那么您可以更改此默认设置（但务必了解自己在做什么）。

请注意，默认情况下，复制品不会驱除数据，因此它可能会使用比 `maxmemory` 设置的内存更多的内存（因为复制品可能具有更大的某些缓冲区或数据结构有时可能占用更多的内存等）。
请确保监视你的复制品，并确保它们具有足够的内存，在主服务器达到配置的 `maxmemory` 设置之前，不会出现真正的内存不足情况。

要更改此行为，您可以允许副本不忽略`maxmemory`。使用的配置指令是：

    replica-ignore-maxmemory no
