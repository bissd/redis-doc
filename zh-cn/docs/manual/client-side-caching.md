---
title: "Redis中的客户端缓存"
linkTitle: "客户端缓存"
weight: 2
description: >
    Redis中的服务器辅助、客户端缓存
aliases:
    - /topics/client-side-caching
---

客户端缓存是一种用于创建高性能服务的技术。
它利用应用服务器上可用的内存（通常与数据库节点是不同的计算机）直接在应用程序端存储数据库信息的子集。

通常情况下，当需要数据时，应用服务器会向数据库询问该信息，如下图所示：


    +-------------+                                +----------+
    |             | ------- GET user:1234 -------> |          |
    | Application |                                | Database |
    |             | <---- username = Alice ------- |          |
    +-------------+                                +----------+

当使用客户端缓存时，应用程序将直接将热门查询的响应存储在应用程序内存中，以便以后重用此类响应，而无需再次联系数据库。

    +-------------+                                +----------+
    |             |                                |          |
    | Application |       ( No chat needed )       | Database |
    |             |                                |          |
    +-------------+                                +----------+
    | Local cache |
    |             |
    | user:1234 = |
    | username    |
    | Alice       |
    +-------------+

虽然用于本地缓存的应用程序内存可能不是很大，
但是与访问网络服务（例如数据库）相比，访问本地计算机内存所需的时间要小得多。
由于经常访问相同的一小部分数据，
这种模式可以极大地减少应用程序获取数据时的延迟，
同时减轻数据库负载。

此外，许多数据集中的项目变化非常稀少。例如，社交网络中的大多数用户帖子要么是不可变的，要么很少被用户编辑。再加上通常只有很小一部分帖子非常受欢迎，要么是因为一小部分用户拥有很多关注者，要么是因为最近的帖子具有更多的可见性，这就解释了为什么这种模式非常实用。

通常客户端缓存的两个关键优势是：

1. 数据具有非常小的延迟可供使用。
2. 数据库系统接收较少的查询请求，使其能够使用较少的节点来提供相同的数据集。

计算机科学有两个难题......

上述模式存在的一个问题是如何使应用程序中保存的信息失效，以避免向用户呈现过期的数据。例如，在上述应用程序本地缓存了user:1234的信息后，Alice可能会将她的用户名更新为Flora。然而，应用程序可能会继续为user:1234提供旧的用户名。

有时候，根据我们模拟的确切应用，这不是个大问题，因此客户端会使用一个固定的最长“存活时间”来缓存信息。一旦经过一定的时间，信息将不再被认为有效。更复杂的模式在使用Redis时，通过发布/订阅系统发送失效消息给监听的客户端。这可以让系统工作，但是在带宽使用上会很麻烦和昂贵，因为通常这种模式会把失效消息发送给应用的每个客户端，即使某些客户端可能没有任何失效数据的副本。此外，每个修改数据的应用程序查询都要使用`PUBLISH`命令，这会增加数据库处理该命令所需的CPU时间。

无论使用什么模式，有一个简单的事实：许多非常大的应用程序都实现了某种形式的客户端缓存，因为它是拥有快速存储或快速缓存服务器的下一个逻辑步骤。因此，Redis 6 实现了对客户端缓存的直接支持，以使该模式更简单、更易于实现、更可靠和更高效。

## 客户端缓存的Redis实现

Redis 客户端的缓存支持被称为_Tracking_，并有两种模式：

* 在默认模式下，服务器会记住客户端访问过的键，并在同一键被修改时发送失效消息。这在服务器端会消耗内存，但只为客户端可能在内存中保存的键集合发送失效消息。
* 在“广播”模式下，服务器不会尝试记住客户端访问过的键，因此这种模式在服务器端没有任何内存消耗。相反，客户端订阅键前缀，如 `object:` 或 `user:`，并在每次与订阅的前缀匹配的键被触摸时接收到通知消息。

为了简单理解，暂时忘记广播模式，重点讨论第一模式。我们稍后会详细描述广播模式。

1. 如果客户端希望，可以启用跟踪功能。连接在启用跟踪之前是未启用的。
2. 当启用跟踪时，服务器会记住每个客户端在连接过程中请求的键（通过发送读取命令获取关于这些键的信息）。
3. 当某个客户端修改了一个键，或者由于存在过期时间而被删除，或者由于_maxmemory_策略而被删除时，所有启用跟踪的客户端都会收到一个"无效消息"。
4. 当客户端收到无效消息时，它们需要移除相应的键，以避免提供过期的数据。

这是协议的示例：

* 客户端1 `->` 服务器：CLIENT TRACKING ON
* 客户端1 `->` 服务器：GET foo
* （服务器记得客户端1可能在缓存中有键"foo"）
* （客户端1可能记得它的本地内存中的"foo"的值）
* 客户端2 `->` 服务器：SET foo SomeOtherValue
* 服务器 `->` 客户端1：INVALIDATE "foo"

这看起来表面上很好，但是如果你想象一下有10k个已连接的客户端，他们都在长期连接上请求数百万个键，那么服务器最终会存储太多的信息。因此，为了限制服务器端使用的内存量和处理实现该功能的数据结构的CPU成本，Redis使用了两个关键思想。

* 服务器在一个单独的全局表中记住可能已经缓存了给定键的客户端列表。这个表被称为**失效表**。失效表可以包含最大数量的条目。如果插入了一个新的键，服务器可以通过假装该键已被修改（即使实际上没有），并向客户端发送一个失效消息来驱逐旧的条目。通过这样做，即使这将迫使拥有该键的本地副本的客户端驱逐它，服务器仍然可以回收用于该键的内存。
* 在失效表中，我们实际上不需要存储客户端结构的指针，这将导致客户端断开连接时需要进行垃圾回收过程：相反，我们只存储客户端的ID（每个Redis客户端都有一个唯一的数字ID）。如果一个客户端断开连接，随着缓存槽被失效，信息将被增量式地进行垃圾回收。
* 有一个单一的键命名空间，不按数据库编号划分。因此，如果一个客户端将键`foo`缓存在数据库2中，而其他客户端更改了数据库3中键`foo`的值，仍然会发送失效消息。通过这种方式，我们可以忽略数据库编号，从而减少内存使用量和实现复杂性。

## 两个连接模式

使用Redis 6支持的新版本Redis协议RESP3，可以在同一连接中运行数据查询并接收无效化消息。然而，许多客户端实现可能更愿意使用两个分开的连接来实现客户端缓存：一个用于数据，一个用于无效化消息。因此，当客户端启用跟踪时，可以通过指定不同连接的“客户端ID”来将无效化消息重定向到另一个连接。许多数据连接可以将无效化消息重定向到同一个连接，这对于实现连接池的客户端非常有用。两个连接模型也是RESP2支持的唯一模型（RESP2不支持在同一连接中复用不同类型的信息）。

以下是使用旧的RESP2模式的Redis协议完成会话的示例，包括以下步骤：启用跟踪重定向到另一个连接，请求一个键，并在键被修改后收到无效消息。

要开始，客户端打开第一个连接，用于无效请求，请求连接ID，并通过Pub/Sub订阅特殊通道，当在RESP2模式下时，用于获取无效消息（请记住RESP2是常规的Redis协议，并不是您可以选择使用的更高级协议，Redis 6可以使用`HELLO`命令）。

```
(Connection 1 -- used for invalidations)
CLIENT ID
:4
SUBSCRIBE __redis__:invalidate
*3
$9
subscribe
$20
__redis__:invalidate
:1
```

现在我们可以通过数据连接启用跟踪：

```
(Connection 2 -- data connection)
CLIENT TRACKING on REDIRECT 4
+OK

GET foo
$3
bar
```

客户端可以决定在本地内存中缓存 "foo" => "bar"。

另一个客户端现在将修改"foo"键的值：

```
(Some other unrelated connection)
SET foo bar
+OK
```

作为结果，失效连接将接收到一条使指定的键失效的消息。

```
(Connection 1 -- used for invalidations)
*3
$7
message
$20
__redis__:invalidate
*1
$3
foo
```
客户端将检查此缓存槽中是否有缓存键，并将清除不再有效的信息。

请注意，Pub/Sub消息的第三个元素不是一个单独的键，而是一个只有一个元素的Redis数组。由于我们发送了一个数组，如果有一组要失效的键，我们可以在一条消息中完成。在刷新（'FLUSHALL'或'FLUSHDB'）的情况下，将发送一个null消息。

关于与RESP2和Pub/Sub连接一起使用的客户端缓存以读取失效消息
的重要一点是，使用Pub/Sub完全是一个技巧，**为了重用旧的客户端
实现**，但实际上消息并不真正发送到通道
并由所有订阅它的客户端接收。只有我们
在`CLIENT`命令的`REDIRECT`参数中指定的连接实际上
将接收到Pub/Sub消息，使得该功能更具可伸缩性。

当使用RESP3时，无效消息被发送为`push`消息（请阅读RESP3规范获取更多信息），发送位置可以是同一连接，也可以是在重定向时的次要连接。

## 跟踪器跟踪什么

如您所见，客户端默认情况下不需要告诉服务器它们正在缓存哪些键。在只读命令的上下文中提到的每个键都将被服务器追踪，因为它们可能被缓存。

这样做的明显优点是不需要客户端告诉服务器需要缓存什么内容。此外，在许多客户端实现中，这是期望的行为，因为一个好的解决方案可能是将尚未缓存的所有内容都缓存起来，使用先进先出的方式：我们可能希望缓存一定数量的对象，每次获取新数据时，我们都可以将其缓存起来，丢弃最旧的缓存对象。更高级的实现可以选择丢弃最不常使用的对象或类似的方法。

请注意，无论如何，如果服务器上有写流量，缓存槽位会在一段时间内失效。一般来说，当服务器假定我们获取的内容也会被缓存时，我们就必须做出权衡：

1. 当客户端倾向于使用一个欢迎新对象的策略来缓存许多内容时，效率更高。
2. 服务器将被迫保留有关客户端键的更多数据。
3. 客户端将收到关于它没有缓存的对象的无用的失效消息。

因此，在下一节中有一种替代方案。

## 使用缓存

客户端实现可能只想缓存选定的键，并明确告知服务器它们将缓存哪些内容和不缓存哪些内容。这将在缓存新对象时需要更多的带宽，但同时减少了服务器需要记住的数据量以及客户端接收到的失效消息数量。

为了实现这一点，必须使用OPTIN选项启用跟踪功能：

    CLIENT TRACKING on REDIRECT 1234 OPTIN

在这种模式下，默认情况下，读查询中提到的键不应该被缓存，而是当客户端想要缓存一些东西时，它必须在实际获取数据之前立即发送一个特殊命令。

    CLIENT CACHING YES
    +OK
    GET foo
    "bar"

`CACHING`命令影响紧随其后的命令的执行，
但是如果下一个命令是`MULTI`，事务中的所有命令都将被跟踪。
同样，在Lua脚本中执行的所有命令也将被跟踪。

## 广播模式

到目前为止，我们已经描述了Redis实现的第一种客户端缓存模型。还有另一种称为广播的模型，它从不同的权衡角度来看待问题，不会在服务器端消耗任何内存，而是向客户端发送更多的失效消息。在这种模式下，我们有以下主要行为：

* 客户端使用`BCAST`选项启用客户端端缓存，并使用`PREFIX`选项指定一个或多个前缀。例如：`CLIENT TRACKING on REDIRECT 10 BCAST PREFIX object: PREFIX user:`。如果没有指定前缀，那么假定前缀为空字符串，因此客户端将接收到所有被修改的键的失效消息。而如果使用了一个或多个前缀，则只有与指定前缀匹配的键会在失效消息中发送。
* 服务器不会将任何内容存储在失效表中。相反，它使用一个不同的**前缀表**，其中每个前缀与客户端列表相关联。
* 两个前缀不能跟踪键空间的重叠部分。例如，不能同时使用前缀"foo"和"foob"，因为它们都会触发键"foobar"的失效。然而，只使用前缀"foo"即可。
* 每当修改任何与前缀匹配的键时，所有订阅该前缀的客户端将接收到失效消息。
* 服务器的 CPU 消耗与注册前缀的数量成比例。如果只有几个前缀，很难看出任何差异。但如果有大量前缀，CPU 成本可能会很高。
* 在这种模式下，服务器可以优化，为订阅给定前缀的所有客户端创建单个回复，并将相同的回复发送给所有客户端。这有助于降低 CPU 使用率。

## NOLOOP选项

默认情况下，客户端跟踪会向修改密钥的客户端发送失效消息。有时候客户端希望这样做，因为它们实现的逻辑非常基本，不涉及自动本地缓存写操作。然而，更高级的客户端可能希望甚至将它们正在进行的写操作缓存到本地内存表中。在这种情况下，在写入后立即接收到失效消息会带来问题，因为它会强制客户端逐出刚刚缓存的值。

在这种情况下可以使用`NOLOOP`选项：它在正常模式和广播模式下均有效。使用该选项，客户端能够告诉服务器，他们不希望接收对他们修改的键的失效消息。

## 避免竞态条件

在实现客户端缓存重定向无效化消息到不同连接时，您应该意识到存在可能的竞争条件。看下面的示例交互，我们将称数据连接为"D"，无效化连接为"I"：

    [D] client -> server: GET foo
    [I] server -> client: Invalidate foo (somebody else touched it)
    [D] server -> client: "bar" (the reply of "GET foo")

正如您所见，由于回复 GET 请求的速度更慢，我们在收到实际数据之前就收到了过期的无效消息。因此，我们将继续提供一个过期的 foo 键版本。为了避免这个问题，当我们发送命令时，最好在缓存中填充一个占位符：

    Client cache: set the local copy of "foo" to "caching-in-progress"
    [D] client-> server: GET foo.
    [I] server -> client: Invalidate foo (somebody else touched it)
    Client cache: delete "foo" from the local cache.
    [D] server -> client: "bar" (the reply of "GET foo")
    Client cache: don't set "bar" since the entry for "foo" is missing.

当使用单个连接同时处理数据和失效消息时，不可能出现这种竞争条件，因为在这种情况下，消息的顺序始终是已知的。

## 当与服务器失去连接时怎么办

同样地，如果我们失去了与用于获取无效化消息的套接字的连接，可能会导致数据变旧。为了避免这个问题，我们需要做以下几件事情：

请确保在连接丢失时刷新本地缓存。

无论是在使用Pub/Sub和RESP2，还是RESP3时，请定期PUBSUB命令（即使在Pub/Sub模式下也可以发送PING命令！）。如果连接看起来断开，而且我们无法接收到PING的回应，在最长时间内关闭连接并清除缓存。

## 什么需要缓存

客户可能希望对缓存键在请求中实际提供服务的次数进行内部统计，以便在未来了解什么适合进行缓存。一般来说：

* 我们不想缓存频繁变动的许多键。
* 我们不想缓存很少请求的许多键。
* 我们希望缓存经常被请求且变化在合理范围内的键。举个不变化在合理范围内的键的例子，想象一个不断进行`INCR`操作的全局计数器。

然而，较简单的客户端可能只是使用一些随机抽样来驱逐数据，仅记住上次使用给定缓存值的时间，试图驱逐最近没有使用过的键。

## 实现客户端库的其他提示

* 处理TTL：确保您还要请求密钥的TTL，并在本地缓存中设置TTL，如果您想支持带有TTL的缓存键。
* 对于每个键都设置最大TTL是一个好主意，即使它没有TTL。这可以防止由于错误或连接问题导致客户端在本地副本中具有旧数据。
* 绝对需要限制客户端使用的内存量。必须有一种方法在添加新键时驱逐旧键。

## 限制Redis使用的内存量

请确保为Redis配置一个合适的最大键记忆值，或者使用不消耗Redis内存的BCAST模式。请注意，当不使用BCAST时，Redis消耗的内存量与跟踪的键数和请求此类键的客户端数成比例。

