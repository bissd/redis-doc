---
title: "Redis FAQ"
linkTitle: "FAQ"
weight: 100
description: >
    开始使用Redis时常见的问题如下：
aliases:
    - /docs/getting-started/faq
---

## Redis与其他键值存储有何不同？

* Redis在键值数据库中有不同的演进路径，其中值可以包含更复杂的数据类型，并对这些数据类型定义了原子操作。Redis数据类型与基本数据结构密切相关，并且将其作为基本数据结构向程序员公开，没有额外的抽象层。
* Redis是一个内存中的持久化数据库，因此它代表了一种不同的权衡，在数据集大小不能超过内存的限制下，实现了非常高的写入和读取速度。内存数据库的另一个优点是，与磁盘上的相同数据结构相比，复杂数据结构的内存表示要简单得多，因此Redis可以用较少的内部复杂性做更多的事情。与此同时，两种磁盘存储格式（RDB和AOF）不需要适用于随机访问，因此它们是紧凑的，并且总是以追加方式生成（即使AOF日志轮换也是追加操作，因为新版本是从内存中的数据副本生成的）。然而，与传统的磁盘存储相比，这种设计也涉及不同的挑战。作为主要的数据表示形式在内存中，必须仔细处理Redis操作，以确保始终在磁盘上有数据集的更新版本。

## Redis的内存占用是多少？

为了给您举几个例子（所有例子都是通过64位实例获得的）：

* 空实例使用约3MB的内存。
* 100万个小键->字符串值对使用约85MB的内存。
* 100万个键->哈希值，表示一个具有5个字段的对象，使用约160MB的内存。

测试您的用例是微不足道的。使用`redis-benchmark`实用程序生成随机数据集，然后使用`INFO memory`命令检查使用的空间。

64位系统将比32位系统使用更多的内存来存储相同的键，特别是当键和值很小的时候。这是因为在64位系统中，指针占用8个字节。但当然，使用64位系统的优点是您可以拥有更多的内存，所以为了运行大型Redis服务器，几乎需要使用64位系统。另一种选择是分片。

为什么Redis将整个数据集保留在内存中？

在过去，Redis开发人员尝试了虚拟内存和其他系统，以便允许大于RAM的数据集，但归根结底，如果我们能做一件事情非常好：从内存中提供数据，使用磁盘进行存储，那我们是非常开心的。所以目前没有计划为Redis创建一个磁盘后端。毕竟，Redis的大部分功能都是其当前设计的直接结果。

如果您真正的问题不是需要更多的总内存，而是需要将数据集分成多个 Redis 实例，请阅读此文档中的[分区页面](/topics/partitioning)以获取更多信息。

Redis有限公司是支持Redis开发的公司，他们开发了一种"Redis on Flash"解决方案，该方案采用混合RAM/闪存的方式处理具有倾斜访问模式的大型数据集。您可以查看他们的提供信息，但这个功能不是开源Redis代码库的一部分。

## 你能在磁盘型数据库中使用Redis吗？

是的，一种常见的设计模式涉及将写入密集的小数据存储在Redis中（并且您需要Redis数据结构以有效地建模问题），将大量*数据块*存储在SQL或具有最终一致性的磁盘数据库中。类似地，有时使用Redis来在内存中获取与磁盘数据库中存储的同一数据子集的另一个副本。这可能看起来类似于缓存，但实际上是一个更高级的模型，因为通常Redis数据集与磁盘数据库数据集一起更新，而不会在缓存未命中时刷新。

## 如何减少Redis的整体内存使用？

好的做法是在将逻辑数据模型映射到Redis中的物理数据模型时考虑内存消耗。这些考虑包括使用特定的数据类型、键模式和规范化。

除了数据建模外，[内存优化页面](/topics/memory-optimization)中还提供更多信息。

如果Redis内存不足会发生什么？

Redis内置了保护机制，允许用户使用配置文件中的`maxmemory`选项设置内存使用的最大限制，将限制应用于Redis可以使用的内存。如果达到了这个限制，Redis将开始回复错误以阻止写入命令（但仍会继续接受只读命令）。

你还可以配置Redis，在达到最大内存限制时驱逐键。有关此内容的详细信息，请参阅[eviction policy docs](/docs/manual/eviction/)。

在Linux上使用fork()时，后台保存可能失败导致错误。

简短回答：`echo 1 > /proc/sys/vm/overcommit_memory` :)

现在是较长的文本：

Redis 后台保存方案依赖于现代操作系统中 `fork` 系统调用的写时复制语义：Redis 进行 fork 操作（创建一个子进程），子进程是父进程的完全副本。子进程将数据库存储在磁盘上，最后退出。理论上，子进程应该消耗与父进程相同的内存，因为它是一个副本，但实际上，多数现代操作系统实现的写时复制语义使得父进程和子进程会共享公共内存页。只有当子进程或者父进程对某页进行修改时，这个页才会被复制。由于在子进程保存数据期间理论上所有页都可能发生变化，Linux 无法预先确定子进程需要多少内存。因此，如果 `overcommit_memory` 设置为零，则如果没有足够的空闲 RAM 可以完全复制父进程的内存页，fork 将会失败。如果你有一个 Redis 数据集大小为 3 GB，而只有 2 GB 的可用内存，那么操作将失败。

将"overcommit_memory"设置为1告诉Linux在更乐观的分配方式下执行fork操作，这正是Redis所需要的。

您可以参考[proc(5)][proc5]手册页，了解可用值的解释。

[proc5]: http://man7.org/linux/man-pages/man5/proc.5.html

## Redis 的磁盘快照是原子操作吗？

是的，当服务器在执行命令之外时，Redis的后台保存进程总是被fork出来，因此每个在RAM中被认为是原子的命令，在磁盘快照的角度也是原子的。

## Redis如何使用多个CPU或核心?

很少有CPU成为Redis的瓶颈，因为通常Redis要么是内存有限，要么是网络有限。
例如，当使用流水线处理时，运行在普通Linux系统上的Redis实例每秒可以处理100万个请求，所以如果您的应用程序主要使用O(N)或O(log(N))命令，它几乎不会使用太多的CPU。

然而，为了最大化CPU的使用率，您可以在同一台主机上启动多个Redis实例，并将它们视为不同的服务器。到某个时候，单个主机可能已经不够了，所以如果您想要使用多个CPU，可以开始考虑一些提前分片的方式。

您可以在[分区页面](/topics/partitioning)上找到有关使用多个Redis实例的更多信息。

在4.0版本之后，Redis开始实现线程化操作。目前，这仅限于在后台删除对象和通过Redis模块实现的阻塞命令。在接下来的发布中，计划逐渐使Redis更加线程化。

## 一个单独的 Redis 实例可以承载的最大键数是多少？Hash、List、Set 和 Sorted Set 中的最大元素数量分别是多少？

Redis 可处理多达 2^32 个键，并且在实践中已经测试过每个实例至少可以处理 2.5 亿个键。

每个哈希、列表、集合和有序集合都可以容纳2^32个元素。

换句话说，你的限制可能是系统中可用的内存。

## 为什么我的副本实例与主实例具有不同数量的键？

如果您使用带有有限生存时间的密钥（Redis到期），这是正常的行为。发生了以下情况：

* 主节点在与副本首次同步时生成一个RDB文件。
* RDB文件不会包含在主节点中已过期但仍在内存中的键。
* 这些键仍然在Redis主节点的内存中，即使它们在逻辑上已过期。它们将被视为不存在，并且它们的内存将在后续增量或访问时被回收。尽管这些键在数据集中在逻辑上不属于其中，但是在INFO输出和DBSIZE命令中仍会进行计算。
* 当副本读取主节点生成的RDB文件时，不会加载这组键。

因此，对于拥有许多已过期密钥的用户来说，副本中的密钥数量较少是很常见的。然而，从逻辑上讲，主服务器和副本服务器的内容应该是相同的。

## "Redis"这个名称的来源是什么？

Redis 是一个首字母缩略词，代表着**RE**mote **DI**ctionary **S**erver。

## 为什么Salvatore Sanfilippo开始了Redis项目？

Salvatore最初创建Redis是为了扩展实时日志分析工具[LLOOGG](https://github.com/antirez/lloogg)。但是在基本的Redis服务器功能完成后，他决定与其他人共享这个工作，并把Redis变成一个开源项目。

## Redis 如何发音？

Redis（/ˈrɛd-ɪs/）的发音类似于单词“red”和单词“kiss”之间去掉“k”。
