---
title: "使用Lua脚本"
linkTitle: "Lua脚本编程"
weight: 2
description: >
   在Redis中执行Lua脚本
aliases:
    - /topics/eval-intro
    - /docs/manual/programmability/eval-intro/
---

Redis允许用户在服务器上上传和执行Lua脚本。
脚本可以使用编程控制结构并在执行过程中使用大多数[命令](/commands)来访问数据库。
由于脚本在服务器上执行，所以从脚本中读取和写入数据非常高效。

Redis保证脚本的原子执行。
在执行脚本期间，所有服务器活动都会被阻塞，直到脚本运行结束。
这些语义意味着脚本的所有效果要么尚未发生，要么已经发生过。

脚本编程提供了几个在许多情况下都非常有价值的属性。
包括：

* 通过在数据所在的地方执行逻辑来提供局部性。数据局部性可以降低总体延迟并节省网络资源。
* 阻塞语义可确保脚本的原子执行。
* 允许组合简单的功能，这些功能要么缺失于Redis，要么太小众而无法成为其一部分。

Lua可以让你在Redis内运行应用程序逻辑的一部分。
这样的脚本可以在多个键之间执行有条件的更新，可能会原子地组合几种不同的数据类型。

脚本是在Redis中由嵌入式执行引擎执行的。
目前，Redis支持一个单一的脚本引擎，即Lua 5.1解释器。
有关完整文档，请参阅[Redis Lua API参考](/topics/lua-api)页面。

尽管服务器执行它们，但评估脚本被视为客户端应用程序的一部分，这就是为什么它们没有命名、没有版本号，也不会持久化。
因此，如果脚本缺失（如服务器重启、切换到副本等），所有的脚本可能需要由应用程序重新加载。
从7.0版本开始，Redis函数提供了一种替代的编程方法，允许服务器本身扩展额外的编程逻辑。

## 入门指南

我们将使用`EVAL`命令开始使用Redis脚本。

这是我们的第一个例子：

```
> EVAL "return 'Hello, scripting!'" 0
"Hello, scripting!"
```

在这个例子中，`EVAL` 接受两个参数。
第一个参数是一个字符串，其中包含脚本的 Lua 源代码。
脚本不需要包含任何 Lua 函数的定义。
它只是一个运行在 Redis 引擎上下文中的 Lua 程序。

第二个参数是接着脚本内容之后的参数个数，从第三个参数开始，代表Redis键的名称。
在这个例子中，我们使用了值 _0_，因为我们没有为脚本提供任何参数，无论是键的名称还是其他内容。

## 脚本参数化

有可能（尽管极为不推荐）使应用程序根据需要动态生成脚本源代码。
例如，应用程序可以发送这两个完全不同但完全相同的脚本：

```
redis> EVAL "return 'Hello'" 0
"Hello"
redis> EVAL "return 'Scripting!'" 0
"Scripting!"
```

虽然 Redis 并没有阻止这种操作模式，但这是一种反模式，因为会考虑脚本缓存方面的问题（详见下文）。
与其让应用程序生成细微差异的相同脚本，不如对其进行参数化，并传递执行所需的任何参数。

如下示例演示了如何通过参数化实现与上述相同的效果：

```
redis> EVAL "return ARGV[1]" 0 Hello
"Hello"
redis> EVAL "return ARGV[1]" 0 Parameterization!
"Parameterization!"
```

现在，理解 Redis 在输入参数中区分键名和非键名之间的区别是至关重要的。

在Redis中，键名称只是字符串，不同于其他字符串值，它们代表了数据库中的键。
键名是Redis中的基本概念，也是操作Redis集群的基础。

**重要提示：**
为了确保脚本能够在单机和集群部署中正确执行，脚本访问的所有键的名称都必须作为输入键参数明确提供。
脚本**只应该**访问那些作为输入参数给出的键。
脚本**永远不应该**访问那些根据程序生成的名称或者基于数据库中存储的数据结构的内容的键。

如果函数的输入不是键名，则是一个常规的输入参数。

在上面的示例中，_Hello_ 和 _Parameterization!_ 都是脚本的常规输入参数。
由于脚本不会操作任何键，我们使用数值参数 _0_ 来指定没有键名参数。
执行上下文通过 [_KEYS_](/topics/lua-api#the-keys-global-variable) 和 [_ARGV_](/topics/lua-api#the-argv-global-variable) 全局运行时变量将参数提供给脚本。
_KEYS_ 表格在脚本执行前使用所提供的所有键名参数进行预填充，而 _ARGV_ 表格则具有类似的作用，但用于常规参数。

以下尝试演示脚本_KEY_和_ARGV_运行时全局变量之间输入参数的分配情况：


```
redis> EVAL "return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] }" 2 key1 key2 arg1 arg2 arg3
1) "key1"
2) "key2"
3) "arg1"
4) "arg2"
5) "arg3"
```

**注意：** 从上面可以看到，Lua的表数组被返回为[RESP2数组回复](/topics/protocol#resp-arrays)，因此您的客户端库可能会将其转换为编程语言中的原生数组数据类型。
请参考[数据类型转换](/topics/lua-api#data-type-conversion)的规则以获取更相关的信息。

## 从脚本中与 Redis 交互

通过[`redis.call()`](/topics/lua-api#redis.call)或[`redis.pcall()`](/topics/lua-api#redis.pcall)可以从Lua脚本中调用Redis命令。

以下两个函数几乎完全相同。
如果传入的参数表示一个正确形式的命令，两者都会执行 Redis 命令以及所提供的参数。
然而，这两个函数的区别在于处理运行时错误（例如语法错误）的方式。
调用 `redis.call()` 函数时引发的错误直接返回给执行它的客户端。
相反，调用 `redis.pcall()` 函数时遇到的错误会被返回到脚本的执行上下文，并可以进行处理。

例如，考虑以下内容：

```
> EVAL "return redis.call('SET', KEYS[1], ARGV[1])" 1 foo bar
OK
```
上述脚本接受一个键名和一个值作为其输入参数。
当执行时，脚本调用`SET`命令，将输入键_foo_设置为字符串值"bar"。

## 脚本缓存

到目前为止，我们使用`EVAL`命令来运行我们的脚本。

无论何时调用`EVAL`，我们都会将脚本的源代码包含在请求中。
重复调用`EVAL`来执行相同的参数化脚本，会浪费网络带宽，并且在Redis中也有一些开销。
自然而然，节约网络和计算资源是关键，因此，Redis为脚本提供了一个缓存机制。

每次使用 `EVAL` 执行的脚本都会存储在服务器维护的专用缓存中。
缓存的内容根据脚本的 SHA1 摘要和求和进行组织，因此脚本的 SHA1 摘要唯一标识缓存中的脚本。
您可以通过运行 `EVAL` 并随后调用 `INFO` 来验证此行为。
您会注意到每次执行新脚本时，_used_memory_scripts_eval_ 和 _number_of_cached_scripts_ 指标都会增长。

如前所述，动态生成的脚本是一种反模式。
在应用程序运行时生成脚本可能会耗尽主机的内存资源以进行缓存。
相反，脚本应尽量通用，并通过其参数提供定制执行。

通过调用“SCRIPT LOAD”命令并提供源代码，将脚本加载到服务器的缓存中。
服务器不会执行脚本，而只是编译并加载到服务器的缓存中。
加载完成后，可以使用服务器返回的SHA1摘要执行缓存的脚本。

下面是一个加载并执行缓存脚本的示例：

```
redis> SCRIPT LOAD "return 'Immabe a cached script'"
"c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f"
redis> EVALSHA c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f 0
"Immabe a cached script"
```

### 缓存波动性

Redis脚本缓存始终是**易失的**。
它不被视为数据库的一部分，也**不会持久化**。
当服务器重新启动时，当副本承担主节点角色时，或者通过`SCRIPT FLUSH`显式清除缓存时，缓存可能会被清空。
这意味着缓存的脚本是暂时的，缓存的内容随时可能丢失。

使用脚本的应用程序应始终调用`EVALSHA`来执行它们。
如果脚本的SHA1摘要不在缓存中，服务器将返回错误。
例如：

```
redis> EVALSHA ffffffffffffffffffffffffffffffffffffffff 0
(error) NOSCRIPT No matching script
```

在这种情况下，应用程序应首先使用`SCRIPT LOAD`加载它，然后再调用`EVALSHA`再次运行基于其SHA1散列值的缓存脚本。
大多数[Redis客户端](/clients)已经提供了自动执行此操作的实用API。
请参考您客户端的文档以了解具体细节。

### 在流水线上使用`!EVALSHA`

应特别注意在处理[管道请求](/topics/pipelining)时执行`EVALSHA`命令。
管道请求中的命令按照发送的顺序执行，但其他客户端的命令可能插入到这些命令之间执行。
因此，管道请求可能会返回`NOSCRIPT`错误，但无法处理。

因此，客户端库的实现在管道的上下文中应该回滚到使用纯粹的`EVAL`的参数化形式。

### 脚本缓存语义

在正常运行期间，应用程序的脚本应该一直保存在缓存中（即，直到服务器重启或刷新缓存）。
背后的原因是，一个良好编写的应用程序的脚本缓存内容不太可能持续增长。
即使是使用了数百个缓存脚本的大型应用程序在缓存内存使用方面也不应该成为问题。

只有通过显式调用`SCRIPT FLUSH`命令才能刷新脚本缓存。
运行此命令将_完全清除_脚本缓存，删除到目前为止执行的所有脚本。
通常，只有在云环境中将实例化给其他客户或应用程序时才需要这样做。

另外，正如已经提到的，重新启动Redis实例会清除非持久化的脚本缓存。
然而，从Redis客户端的观点来看，确保在两个不同命令之间Redis实例没有重新启动仅有两种方法：

* 与服务器的连接是持久的，并且迄今为止从未关闭。
* 客户端明确检查 `INFO` 命令中的 `run_id` 字段，以确保服务器没有重新启动且仍为同一进程。

从实际角度来看，对于客户端而言，在给定连接的上下文中假设缓存脚本是存在的，除非管理员显式地调用 `SCRIPT FLUSH` 命令，这样会更简单。
用户可以依赖 Redis 保留缓存脚本这一事实，在流水线上下文中语义上非常有帮助。

## `!SCRIPT` 命令

Redis `SCRIPT` 提供了几种控制脚本子系统的方式。

这些方式包括：

* `SCRIPT FLUSH`：这个命令是强制Redis刷新脚本缓存的唯一方式。
  在同一个Redis实例被重新分配给不同用途的环境中，它非常有用。
  这也有助于测试客户端库对脚本功能的实现。

* `SCRIPT EXISTS` ：给定一个或多个 SHA1 摘要作为参数，此命令返回一个由 1 和 0 组成的数组。
  1 表示特定的 SHA1 已被识别为已存在于脚本缓存中的脚本。0 的含义是此 SHA1 的脚本之前未被加载过（或者至少在最近的 `SCRIPT FLUSH` 调用之后从未加载过）。

* `SCRIPT LOAD script`：该命令将指定的脚本注册到Redis脚本缓存中。
这是一个有用的命令，在所有我们希望确保`EVALSHA`不失败的上下文中使用（例如在管道中或从[`MULTI`/`EXEC`事务]中调用时](/topics/transactions))，无需执行脚本。

* `SCRIPT KILL`：这个命令是唯一中断长时间运行脚本（又称慢脚本）的方法（除了关闭服务器）。
   一旦脚本的执行时间超过配置的[最大执行时间](/topics/programmability#maximum-execution-time)阈值，它就被认为是慢脚本。
   `SCRIPT KILL`命令只能用于执行期间没有修改数据集的脚本（因为停止只读脚本不会违反脚本引擎保证的原子性）。

* `SCRIPT DEBUG`：控制是否使用内置的[Redis Lua脚本调试器](/topics/ldb)。

## 脚本复制

在独立部署中，一个称为“主节点”的Redis实例管理整个数据库。
一个[集群化部署](/topics/cluster-tutorial)至少有三个主节点来管理分片数据库。
Redis使用[复制](/topics/replication)来维护一个或多个给定主节点的副本或精确拷贝。

因为脚本可以修改数据，所以 Redis 确保脚本执行的所有写操作也会发送到副本以保持一致性。
在脚本复制方面，有两种概念上的方法：

1. 逐字复制：主节点将脚本的源代码发送给副本。
   副本然后执行脚本并应用写入效果。
   在短脚本生成许多命令的情况下（例如，一个_for_循环），这种模式可以节省复制带宽。
   然而，这种复制模式意味着副本要重新执行主节点已经完成的相同工作，这是浪费的。
   更重要的是，它还需要[所有写入脚本都是确定性的](#具有确定性写入的脚本)。
2. 效果复制：只有脚本的数据修改命令被复制。
   然后副本运行这些命令而不执行任何脚本。
   虽然在网络流量方面可能更长，但这种复制模式在定义上是确定性的，因此不需要特殊考虑。

直到Redis 3.2，只支持逐字稿复制模式，其中添加了效果复制。
可以使用_lua-replicate-commands_配置指令和[`redis.replicate_commands()`](/topics/lua-api#redis.replicate_commands) Lua API来启用它。

在Redis 5.0中，效果复制成为默认模式。
截至Redis 7.0，逐字复制不再受支持。

### 复制命令而不是脚本

从Redis 3.2开始，可以选择替代的复制方法。
而不是复制整个脚本，我们可以复制脚本生成的写入命令。
我们将其称为**脚本效果复制**。

**注意：**
从Redis 5.0开始，脚本效果复制是默认模式，无需显式启用。

在这个复制模式中，当Lua脚本被执行时，Redis会收集由Lua脚本引擎实际修改数据集的所有命令。
当脚本执行完成时，脚本生成的命令序列会被包装成一个 [`MULTI`/`EXEC`事务](/topics/transactions)，并发送到副本和AOF。

这在不同的情况下有多种用途：

* 当脚本计算速度较慢，但效果可以用几个写命令来概括时，重新计算脚本在副本中或在重新加载AOF时是一种浪费。
  在这种情况下，更好的做法是只复制脚本的效果。
* 启用脚本效果复制后，对非确定性函数的限制被移除。
  例如，您可以在脚本中的任何位置自由地使用 `TIME` 或 `SRANDMEMBER` 命令。
* 在此模式下，Lua PRNG 在每次调用时都会以随机种子进行初始化。

除非服务器的配置或默认设置已启用（Redis 7.0 之前），否则在脚本执行写入操作之前，您需要执行以下 Lua 命令：

```lua
redis.replicate_commands()
```

[`redis.replicate_commands()`](/topics/lua-api#redis.replicate_commands) 函数返回 _true_，如果启用了脚本效果复制；
否则，如果在脚本已经调用写入命令之后调用了该函数，
它返回 _false_，并且使用正常的整个脚本复制。

这个函数从Redis 7.0开始已弃用，虽然你仍然可以调用它，但它将永远成功。

### 具有确定性写入的脚本

**注意：**
从 Redis 5.0 开始，默认的脚本复制是基于效果而不是逐字的。
在 Redis 7.0 中，逐字的脚本复制完全被移除。
以下部分仅适用于低于 Redis 7.0 版本且未使用基于效果的脚本复制的情况。

脚本编写的一个重要部分是编写只以确定方式更改数据库的脚本。
在Redis实例中执行的脚本在默认情况下（直到5.0版本），通过发送脚本本身而不是结果命令，被传播到副本和AOF文件。
由于脚本将在远程主机上重新运行（或重新加载AOF文件），它对数据库的更改必须是可重现的。

发送脚本的原因是它通常比发送脚本生成的多个命令要快得多。
如果客户端将许多脚本发送到主服务器，在复制链接或追加日志文件(AOF)中将脚本转换为独立命令将导致带宽过高(并且在Redis中，通过网络接收命令与通过Lua脚本调用命令相比，后者需要更多的CPU处理)。

通常情况下，复制脚本的效果而不是脚本本身是有意义的，但并非所有情况都是如此。
因此，从Redis 3.2开始，脚本引擎可以选择复制由脚本执行产生的写入命令序列，而不是复制脚本本身。

在本节中，我们将假设脚本通过发送整个脚本以原文复制。
我们将称之为**逐字脚本复制**。

*整个脚本复制*方法的主要缺点是，脚本必须具备以下特性：
脚本在给定相同的输入数据集时，**必须总是**执行相同的Redis _写入_命令，带有相同的参数。
脚本执行的操作不能依赖于任何隐含（非显式）的信息或状态，这些信息或状态在脚本执行过程中或不同脚本执行之间可能会发生变化。
也不能依赖于来自I/O设备的任何外部输入。

像使用系统时间、调用返回随机值的Redis命令（例如，`RANDOMKEY`），或者使用Lua的随机数生成器等行为可能导致脚本无法一致评估。

为了确保脚本的确定性行为，Redis执行以下操作：

* Lua不提供访问系统时间或其他外部状态的命令。
* 如果脚本调用了一个能够修改数据集的Redis命令（例如`RANDOMKEY`、`SRANDMEMBER`、`TIME`）之后，Redis将阻塞该脚本并显示错误。
这意味着只读脚本不会修改数据集，可以调用这些命令。
请注意，_random command_并不一定意味着使用随机数的命令：任何非确定性的命令都被视为随机命令（最好的例子是`TIME`命令）。
* 在Redis 4.0版本中，可能以随机顺序返回元素的命令（例如`SMEMBERS`，因为Redis的Set是无序的）在从Lua调用时表现出不同的行为，并在返回数据给Lua脚本之前经过了一个静默的词典排序过滤器。
因此，`redis.call("SMEMBERS",KEYS[1])`将始终以相同的顺序返回Set的元素，而即使键包含完全相同的元素，通过常规客户端调用的相同命令可能会返回不同的结果。
然而，从Redis 5.0开始，不再执行此排序，因为复制效果可以规避这种非确定性。
一般来说，即使是为Redis 4.0开发，也不要假设Lua中的某些命令是有序的，而是依赖于您调用的原始命令的文档来查看它提供的属性。
* Lua的伪随机数生成函数`math.random`被修改为每次执行时始终使用相同的种子。
这意味着每次执行脚本时，调用`math.random`都会生成相同的数字序列（除非使用了`math.randomseed`）。

所有以上所说的，您仍然可以使用写入指令和随机行为的方式来进行简单的操作。
想象一下，您想要编写一个 Redis 脚本，用于将一个列表填充为 N 个随机整数。

以Ruby的初始实现可以看起来类似这样：

```
require 'rubygems'
require 'redis'

r = Redis.new

RandomPushScript = <<EOF
    local i = tonumber(ARGV[1])
    local res
    while (i > 0) do
        res = redis.call('LPUSH',KEYS[1],math.random())
        i = i-1
    end
    return res
EOF

r.del(:mylist)
puts r.eval(RandomPushScript,[:mylist],[10,rand(2**32)])
```

每次运行此代码，生成的列表将恰好具有以下元素：

```
redis> LRANGE mylist 0 -1
 1) "0.74509509873814"
 2) "0.87390407681181"
 3) "0.36876626981831"
 4) "0.6921941534114"
 5) "0.7857992587545"
 6) "0.57730350670279"
 7) "0.87046522734243"
 8) "0.09637165539729"
 9) "0.74990198051087"
10) "0.17082803611217"
```

为了使脚本既有确定性又能产生不同的随机元素，我们可以向脚本添加一个额外参数作为Lua伪随机数生成器的种子。新的脚本如下所示：

```
RandomPushScript = <<EOF
    local i = tonumber(ARGV[1])
    local res
    math.randomseed(tonumber(ARGV[2]))
    while (i > 0) do
        res = redis.call('LPUSH',KEYS[1],math.random())
        i = i-1
    end
    return res
EOF

r.del(:mylist)
puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))
```

我们在这里做的是将伪随机数生成器的种子作为其中一个参数发送。
脚本输出将始终相同，给定相同的参数（我们的要求），但是在每次调用时我们将更改其中一个参数，
在客户端生成随机种子。
该种子将作为其中一个参数传播到复制链接和追加文件中，
确保当重新加载AOF或副本处理脚本时生成相同的更改。

注意：这种行为的一个重要部分是，Redis实现的PRNG（伪随机数生成器）`math.random`和`math.randomseed`保证在运行Redis的系统体系结构不同的情况下具有相同的输出。
无论是32位还是64位、大端还是小端系统都会产生相同的输出。

## 调试 Eval 脚本

从Redis 3.2开始，Redis支持原生Lua调试。
Redis Lua调试器是一个由服务器和客户端组成的远程调试器，其中服务器是Redis本身，默认情况下客户端是[`redis-cli`](/topics/rediscli)。

Lua调试器在Redis文档的[Lua脚本调试](/topics/ldb)部分中进行了描述。

## 执行低内存条件下

当Redis的内存使用超过`maxmemory`限制时，脚本中使用了额外内存的第一个写入命令会导致脚本中止（除非使用了[`redis.pcall`](/topics/lua-api#redis.pcall)）。

然而，上述规则的一个例外是当脚本的第一个写入命令不使用额外的内存，就像使用 `DEL` 和 `LREM` 这样的命令一样。
在这种情况下，Redis 将允许脚本中的所有命令运行，以确保原子性。
如果脚本中的后续写入命令使用了额外的内存，Redis 的内存使用量可能会超过由 `maxmemory` 配置指令设置的阈值。

另一种情况是在Redis略低于`maxmemory`时执行脚本，脚本的第一条写入命令被允许执行，这会导致内存使用量超过`maxmemory`阈值。
随着脚本执行，后续的写入命令会消耗更多的内存，导致服务器使用的内存超过配置的`maxmemory`指令。

在这些情况下，您应该考虑将`maxmemory-policy`配置指令设置为除`noeviction`之外的其他值。
此外，Lua脚本应尽可能快，以便在执行之间触发驱逐操作。

请注意，您可以通过使用 [标记](#eval-flags) 来更改这种行为。

## 评估标志位

通常情况下，当您运行评估脚本时，服务器不知道它如何访问数据库。
默认情况下，Redis假定所有脚本都会读取和写入数据。
然而，从Redis 7.0开始，可以在创建脚本时声明标志，以告诉Redis它应该如何行事。

通过在脚本的第一行使用Shebang语句来实现这个目标，就像这样：

```
#!lua flags=no-writes,allow-stale
local x = redis.call('get','x')
return x
```

请注意，一旦Redis看到`#!`注释，即使没有定义标志，它也会将脚本视为声明标志的脚本，
它仍然有一组不同的默认值，与没有`#!`行的脚本不同。

另一个区别是没有 `#!` 的脚本可以运行访问属于不同集群哈希槽的键的命令，但有 `#!` 的脚本会继承默认标志，因此不能。

请参阅[脚本标志](/topics/lua-api#script_flags)了解各种脚本和默认值。
