---
title: "Redis的可编程性"
linkTitle: "可编程性"
weight: 20
description: >
   通过Lua和Redis函数扩展Redis
aliases:
    - /topics/programmability
    - /docs/manual/programmability/
---

Redis提供了一个编程接口，可以在服务器上执行自定义脚本。在Redis 7及更高版本中，您可以使用[Redis函数](/docs/manual/programmability/functions-intro)来管理和运行您的脚本。在Redis 6.2及以下版本中，您可以使用[EVAL命令的Lua脚本](/docs/manual/programmability/eval-intro)来编程服务器。

## 背景

Redis是根据[定义](https://github.com/redis/redis/blob/unstable/MANIFESTO#L7)而言，一个_"面向抽象数据类型的特定领域语言"_。
Redis使用的语言包括其[命令](/commands)。
大部分命令都专门用于以不同方式操作核心的[数据类型](/topics/data-types-intro)。
在许多情况下，这些命令提供了开发人员在Redis中管理应用数据所需的所有功能。

在Redis中，**可编程性**一词指的是服务器能够执行任意用户定义的逻辑。
我们称这些逻辑片段为**脚本**。
在我们的情况下，脚本使数据在其所在的位置进行处理，也即所谓的数据本地性。
此外，在Redis服务器中负责嵌入编程工作流程可以帮助减少网络流量并提高整体性能。
开发人员可以利用此功能来实现强大的、应用特定的API。
这些API可以封装业务逻辑，并在多个键和不同的数据结构之间维护数据模型。

用户脚本在Redis中由一个内嵌的、沙盒化的脚本引擎执行。
目前，Redis支持一个脚本引擎，即[Lua 5.1](https://www.lua.org/)解释器。

请参考完整文档，请点击[Redis Lua API参考](/topics/lua-api)页面。

## 运行脚本

Redis 提供了两种运行脚本的方法。

首先，从Redis 2.6.0开始，`EVAL`命令使得运行服务器端脚本成为可能。
使用Eval脚本可以快速而直接地让Redis运行您的脚本。
然而，使用它们意味着脚本逻辑是应用程序的一部分，而不是Redis服务器的扩展。
每个运行脚本的应用实例必须随时可用地加载脚本的源代码。
这是因为脚本只被服务器缓存，是易变的。
随着应用程序的发展，使用这种方法可能变得更难开发和维护。

## 其次，在v7.0中新增的Redis函数实质上是作为一流的数据库元素的脚本。
因此，函数可以将脚本与应用逻辑解耦，并实现脚本的独立开发、测试和部署。
要使用函数，首先需要将其加载，然后它们就可以被所有连接的客户端使用。
在这种情况下，将函数加载到数据库中成为了一项与管理相关的部署任务（例如，加载Redis模块），从而将脚本与应用程序分离。

请参考以下页面了解更多信息：



* [Redis Eval Scripts](/topics/eval-intro)
* [Redis Functions](/topics/functions-intro)

在运行脚本或函数时，Redis保证其原子执行。
脚本的执行会在整个时间段内阻塞所有服务器活动，类似于事务的语义。
这些语义意味着脚本的所有影响要么尚未发生，要么已经发生。
执行的脚本的阻塞语义始终适用于所有连接的客户端。

请注意，此阻塞方法的潜在缺点是执行慢脚本不是一个好主意。
创建快速脚本并不困难，因为脚本的开销非常低。
然而，如果您打算在应用程序中使用慢脚本，请注意所有其他客户端都被阻塞，无法执行任何命令。

## 只读脚本

只读脚本是指只执行不修改 Redis 中任何键值的命令的脚本。
只读脚本可以通过在脚本中添加 `no-writes` [标志](/topics/lua-api#script_flags) 或者使用只读脚本命令变量之一 `EVAL_RO`、`EVALSHA_RO` 或 `FCALL_RO` 来执行。
它们具有以下特性：

* 它们始终可以在副本上执行。
* 通过`SCRIPT KILL`命令，它们始终可以被终止。
* 当Redis超过内存限制时，它们不会因为OOM错误而失败。
* 在写入暂停期间，例如协调故障转移期间的暂停，它们不会被阻塞。
* 它们无法执行可能修改数据集的任何命令。
* 目前，在脚本中，`PUBLISH`、`SPUBLISH`和`PFCOUNT`也被视为写入命令，因为它们可能会尝试将命令传播到副本和AOF文件中。

除了所有只读脚本提供的好处外，只读脚本命令还具有以下优势：

* 它们可以用于配置ACL用户只能执行只读脚本。
* 许多客户端还支持将只读脚本命令路由到副本，以供希望使用副本进行读取扩展的应用程序使用。

#### 只读脚本历史记录

Redis 7.0引入了只读脚本和只读脚本命令。

* 在Redis 7.0.1之前，`PUBLISH`、`SPUBLISH`和`PFCOUNT`在脚本中不被视为写命令。
* 在Redis 7.0.1之前，`no-writes` [flag](/topics/lua-api#script_flags)不意味着`allow-oom`。
* 在Redis 7.0.1之前，`no-writes` flag不允许脚本在写暂停期间运行。


使用标准脚本命令和`no-writes`标志是推荐的方法，除非你需要之前提到的其中一个功能。

## 受限脚本上下文

Redis将执行用户脚本的引擎放置在一个沙箱中。
该沙箱试图防止意外的误用，并减少来自服务器环境的潜在威胁。

脚本永远不应该尝试访问Redis服务器的底层主机系统，如文件系统、网络，也不应该尝试执行除API支持的系统调用之外的任何其他系统调用。

脚本应仅操作存储在Redis中的数据和提供给它们执行的参数数据。

## 最大执行时间

脚本受最大执行时间限制（默认为五秒）。
这个默认超时时间非常大，因为脚本通常在不到一毫秒的时间内运行。
这一限制是为了处理在开发过程中意外创建的无限循环。

可以通过毫秒精确度修改脚本的最大执行时间，可以通过`redis.conf`文件或使用`CONFIG SET`命令来实现。
影响最大执行时间的配置参数称为`busy-reply-threshold`。

当脚本达到超时阈值时，Redis不会自动终止脚本执行。
这样做将违反 Redis 与脚本引擎之间的契约，该契约确保脚本是原子的。
中断脚本执行有可能导致数据集中存在未完成的更改。

因此，当脚本执行时间超过配置的超时时间时，会发生以下情况：

* Redis 日志显示脚本运行时间过长。
* 它会再次接受其他客户端的命令，但对发送正常命令的客户端会回复“BUSY”错误。在此状态下，只允许使用 `SCRIPT KILL`、`FUNCTION KILL` 和 `SHUTDOWN NOSAVE` 命令。
* 使用 `SCRIPT KILL` 和 `FUNCTION KILL` 命令可以终止只执行只读命令的脚本。这些命令不会违反脚本的语义，因为脚本尚未向数据集写入任何数据。
* 如果脚本已经执行了至少一次写操作，那么唯一允许的命令是 `SHUTDOWN NOSAVE`，它停止服务器并且不保存当前数据集到硬盘（基本上是终止了服务器）。
