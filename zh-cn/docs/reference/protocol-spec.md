---
title: "Redis序列化协议规范"
linkTitle: "协议规范"
weight: 4
description: Redis序列化协议（RESP）是客户端实现的传输协议。
aliases:
    - /topics/protocol
---

要与Redis服务器通信，Redis客户端使用一种称为Redis序列化协议（RESP）的协议。
尽管该协议专门设计用于Redis，但您也可以在其他客户端-服务器软件项目中使用它。

RESP是以下考虑因素的折中：

* 实现简单。
* 解析速度快。
* 可读性强。

RESP可以序列化不同的数据类型，包括整数、字符串和数组。
它还具有特定错误类型。
客户端将请求作为字符串数组发送到Redis服务器。
数组的内容是服务器应该执行的命令及其参数。
服务器的回复类型与命令有关。

RESP 是二进制安全的，并使用前缀长度来传输大块数据，因此它不需要处理从一个进程传输到另一个进程的大块数据。

RESP是您应该在Redis客户端实现的协议。

{{% alert title="Note" color="info" %}}
这里提供的协议仅用于客户端与服务器之间的通信。
[Redis 集群](/docs/reference/cluster-spec) 使用不同的二进制协议来交换节点之间的消息。
{{% /alert %}}

## RESP版本
Redis 1.2中引入了对RESP协议第一个版本的支持。
在Redis 1.2中使用RESP是可选的，主要是为了解决协议中的问题。

在Redis 2.0中，协议的下一个版本，即RESP2，成为客户端与Redis服务器进行通信的标准方法。

[RESP3](https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md)是RESP2的一个超集，主要目的是让客户端的作者的生活变得更容易一些。
Redis 6.0引入了实验性的、可选择的RESP3特性支持（不包括流式字符串和流式聚合）。
此外，通过引入`HELLO`命令，客户端可以进行握手并升级连接的协议版本（请参见[客户端握手](#client-handshake)）。

在Redis 7及其之前的版本中，RESP2和RESP3客户端都可以调用所有核心命令。
然而，不同的协议版本可能会返回不同类型的回复。

未来版本的Redis可能会更改默认的协议版本，但是RESP2不太可能完全废弃。
然而，即将推出的新版本中可能会需要使用RESP3的新功能。

## 网络层
客户端通过创建到Redis服务器端口的TCP连接(默认为6379)来连接到Redis服务器。

虽然RESP在技术上不特定于TCP，但在Redis的上下文中，该协议仅与TCP连接（或等效的面向流的连接，如Unix套接字）配合使用。

## 请求-响应模型
Redis 服务器接受由不同参数组成的命令。
然后，服务器处理命令并将回复发送回客户端。

这是可能的最简单的模型；然而，有一些例外情况：

* Redis请求可以进行[流水线化](#多个命令和流水线化)。流水线化允许客户端一次发送多个命令，并在以后等待回复。
* 当一个RESP2连接订阅一个[发布/订阅](/docs/manual/pubsub)频道时，协议会改变语义，变成一个“推送”协议。客户端不再需要发送命令，因为服务器会自动将新消息发送给客户端（对于客户端订阅的频道），一旦它们被接收到。
* `MONITOR`命令。调用`MONITOR`命令将连接切换到即时推送模式。该模式的协议没有指定，但明显易于解析。
* [受保护模式](/docs/management/security/#protected-mode)。在受保护模式下，非回环地址连接到Redis会被服务器拒绝和终止。在终止连接之前，Redis无条件地发送一个`-DENIED`回复，无论客户端是否向套接字写入。
* [RESP3推送类型](#resp3-pushes)。顾名思义，推送类型允许服务器向连接发送带外数据。服务器可以随时推送数据，这些数据不一定与客户端执行的特定命令相关。
  
除了这些例外情况外，Redis协议是一种简单的请求-响应协议。

## RESP协议描述
RESP 本质上是一个支持多种数据类型的序列化协议。
在 RESP 中，数据的第一个字节决定了它的类型。

Redis通常以以下方式使用RESP作为[请求-响应模型](#request-response-model)的协议：

* 客户端以 Redis 服务器的命令的[数组](#arrays)形式发送命令。数组中的第一个（有时也是第二个）批量字符串是命令的名称。数组的后续元素是命令的参数。
* 服务器以 RESP 类型回复。
  回复的类型取决于命令的实现，可能还取决于客户端的协议版本。

RESP 是一个使用标准 ASCII 编码的二进制协议，它使用控制序列进行编码。
例如，字符 `A` 使用二进制字节值 65 进行编码。
类似地，字符 CR (`\r`)、LF (`\n`) 和 SP (` `) 分别具有二进制字节值 13、10 和 32。

`\r\n`（CRLF）是协议的“终止符”，它始终分隔其各个部分。

在 RESP 序列化负载中，第一个字节总是用于标识其类型。
随后的字节构成了该类型的内容。

我们将每种RESP数据类型分为_简单_、_批量_或_聚合_。

简单类型类似于表示纯字面值的编程语言中的标量。布尔值和整数就是这样的例子。

RESP字符串可以是_simple_或者_bulk_。
简单字符串永远不包含回车（`\r`）或者换行（`\n`）字符。
Bulk字符串可以包含任意二进制数据，也可以称为_binary_或者_blob_。
注意，客户端可以对bulk字符串进行进一步的编码和解码，例如使用宽多字节编码。

聚合对象，如数组和映射，可以具有不同数量的子元素和嵌套层级。

下表总结了Redis支持的RESP数据类型:

| RESP数据类型 |
|------------|
| Simple Strings |
| Error |
| Integer |
| Bulk Strings |
| Arrays |

| RESP 数据类型 | 最小协议版本 | 类别 | 第一个字节 |
| --- | --- | --- | --- |
| [简单字符串](#简单字符串) | RESP2 | 简单 | `+` |
| [简单错误](#简单错误) | RESP2 | 简单 | `-` |
| [整数](#整数) | RESP2 | 简单 | `:` |
| [块字符串](#块字符串) | RESP2 | 聚合 | `$` |
| [数组](#数组) | RESP2 | 聚合 | `*` |
| [空](#空) | RESP3 | 简单 | `_` |
| [布尔值](#布尔值) | RESP3 | 简单 | `#` |
| [双精度数](#双精度数) | RESP3 | 简单 | `,` |
| [大数](#大数) | RESP3 | 简单 | `(` |
| [块错误](#块错误) | RESP3 | 聚合 | `!` |
| [逐字字符串](#逐字字符串) | RESP3 | 聚合 | `=` |
| [映射](#映射) | RESP3 | 聚合 | `%` |
| [集合](#集合) | RESP3 | 聚合 | `~` |
| [推送](#推送) | RESP3 | 聚合 | `>` |

<a name="simple-string-reply"></a>

### 简单字符串
简单字符串以加号（`+`）字符编码，后面跟着一个字符串。
字符串不能包含CR（`\r`）或LF（`\n`）字符，以CRLF（即`\r\n`）结束。

简单字符串传递短的、非二进制的字符串并且开销最小。
例如，许多Redis命令只在成功时回复"OK"。
这个简单字符串的编码是以下5个字节：

    +OK\r\n

当Redis回复一个简单字符串时，客户端库应该将以`+`后的第一个字符组成的字符串值返回给调用者，直到字符串的结尾，但不包括最后的CRLF字节。

要发送二进制字符串，请使用[bulk string](#bulk-strings)。

<a name="error-reply">错误回复</a>

### 简单错误
RESP针对错误具有特定的数据类型。
简单错误，或简称为错误，与[simple strings](#simple-strings)类似，但其第一个字符是减号（`-`）字符。
RESP中简单字符串和错误之间的区别在于客户端应将错误视为异常，而错误类型中编码的字符串本身是错误消息。

基本格式如下：

    -Error message\r\n

Redis仅在发生错误时回复错误，例如，当您尝试对错误的数据类型进行操作时，或者当命令不存在时。
客户端应在收到错误回复时引发异常。

以下是错误回复的示例：

    -ERR unknown command 'asdf'
    -WRONGTYPE Operation against a key holding the wrong kind of value

在`-`之后的第一个大写字母开头的单词，直到第一个空格或换行符，表示返回的错误类型。
这个单词被称为“错误前缀”。
请注意，错误前缀是Redis使用的惯例，而不是RESP错误类型的一部分。

例如，在Redis中，`ERR`是一个通用错误，而`WRONGTYPE`是一个更具体的错误，它意味着客户端尝试对错误的数据类型进行操作。
错误前缀使客户端能够理解服务器返回的错误类型，而无需检查具体的错误消息。

客户端实现可以针对不同的错误返回不同类型的异常，也可以通过直接提供错误名作为字符串的方式为调用者提供统一的错误捕获方式。

然而，这样的功能不应被认为是必不可少的，因为它很少有用。
此外，更简单的客户端实现可以返回一个通用的错误值，比如`false`。

### 整数回复

- **Reply**: 返回一个整数回复。

#### 命令

```
INCR key
```

#### 返回值

- 整数值： key 的新值。

#### 示例

####  Sinple Strings

```
127.0.0.1:6379> SET mykey 10
OK
127.0.0.1:6379> INCR mykey
(integer) 11
127.0.0.1:6379> GET mykey
"11"
127.0.0.1:6379> 
```

####  Error

如果 value 的值不能被解释为十进制数字， 例如，命令用一个字符串"foo"来代替键mykey， 我们将得到一个错误。

```
127.0.0.1:6379> SET mykey foo
OK
127.0.0.1:6379> INCR mykey
(error) ERR value is not an integer or out of range
127.0.0.1:6379> 
```

在上面的例子中，当key的值为"foo"时，命令的返回值/错误有时是难以预料的。

### 整数
这种类型是一个以CRLF结尾的字符串，表示一个有符号的、以10为底的、64位整数。

RESP将整数编码如下：

    :[<+|->]<value>\r\n

* 冒号 (`:`) 作为第一个字节。
* 可选的加号 (`+`) 或减号 (`-`) 作为符号。
* 一个或多个十进制数字 (`0`..`9`) 作为整数的无符号、十进制值。
* CRLF 终止符。

例如，`:0\r\n`和`:1000\r\n`分别是整数回复（零和一千）。

许多Redis命令返回RESP整数，包括`INCR`，`LLEN`和`LASTSAVE`。
一个整数本身没有特殊的含义，除非在返回它的命令上下文中。
例如，对于`INCR`来说，它是一个递增的数字；对于`LASTSAVE`来说，它是一个UNIX时间戳，等等。
不过，返回的整数保证在有符号64位整数的范围内。

在某些情况下，整数可以表示真和假的布尔值。
例如，`SISMEMBER` 返回 1 表示真，返回 0 表示假。

其他命令，包括`SADD`、`SREM`和`SETNX`，在数据发生变化时返回1，否则返回0。

<a name="批量字符串回复"></a>

### 模糊字符串
一个批量字符串表示一个单独的二进制字符串。
字符串的大小可以是任意的，但是默认情况下，Redis将其限制为512MB（参见`proto-max-bulk-len`配置指令）。

RESP以以下方式编码批量字符串：

    $<length>\r\n<data>\r\n

*美元符号（`$`）作为第一个字节。
*一个或多个十进制数字（`0`..`9`）作为字符串的长度，以字节为单位，表示为无符号的十进制值。
* CRLF终止符。
*数据。
*最后的CRLF。

所以字符串"hello"的编码如下：

    $5\r\nhello\r\n

空字符串的编码格式是：

    $0\r\n\r\n

<a name="nil-reply"></a>

#### 空的块字符串
由于历史原因，RESP2中的空值表示通过预定形式的批量字符串和数组类型，而不是像RESP3那样拥有专用的空值数据类型。

null bulk string 表示不存在的值。
当目标键不存在时，`GET` 命令返回 Null Bulk String。

这段文本以长度为负一（-1）的块字符串的形式进行编码，如下所示：

    $-1\r\n

当服务器回复了一个空的批量字符串时，Redis客户端应该返回一个nil对象，而不是空字符串。
例如，Ruby库应该返回`nil`，而C库应该返回`NULL`（或在回复对象中设置一个特殊标志）。

<a name="array-reply"></a>

### 数组
客户端将命令作为 RESP 数组发送到 Redis 服务器。
同样，一些返回元素集合的 Redis 命令使用数组作为回复。
一个例子是 `LRANGE` 命令，它返回列表的元素。

RESP数组的编码使用以下格式：

    *<number-of-elements>\r\n<element-1>...<element-n>

* 作为第一个字节的星号（`*`）。
* 一个或多个十进制数字（`0`..`9`）作为无符号的数组元素数量，以十进制表示。
* CRLF 终止符。
* 数组中每个元素的额外 RESP 类型。

所以一个空数组就是以下内容：

    *0\r\n

数组编码由两个bulk string "hello"和"world"组成：

    *2\r\n$5\r\nhello\r\n$5\r\nworld\r\n

如您所见，在数组前缀的`*<count>CRLF`部分之后，数组中的其他数据类型依次串联在一起。
例如，一个由三个整数组成的数组编码如下：

    *3\r\n:1\r\n:2\r\n:3\r\n

数组可以包含不同的数据类型。
例如，以下编码是一个包含四个整数和一个块字符串的列表：

    *5\r\n
    :1\r\n
    :2\r\n
    :3\r\n
    :4\r\n
    $5\r\n
    hello\r\n


（原始的 RESP 编码为了可读性而分成多行）。

服务器发送的第一行是 `*5\r\n`。
这个数字告诉客户端紧随其后有五个回复类型。
然后，每个连续的回复都构成数组中的一个元素。

所有的聚合 RESP 类型都支持嵌套。
例如，一个包含两个数组的嵌套数组可以编码如下：

    *2\r\n
    *3\r\n
    :1\r\n
    :2\r\n
    :3\r\n
    *2\r\n
    +Hello\r\n
    -World\r\n

(原始的RESP编码被拆分成多行以提高可读性)。

上述编码了一个包含两个元素的数组。
第一个元素是一个数组，其中包含三个整数（1，2，3）。
第二个元素是另一个数组，包含一个简单字符串和一个错误。

{{% alert title="Multi bulk reply" color="info" %}}
在一些地方，RESP数组类型可能被称为“多批量”。
两者是相同的。
{{% /alert %}}

<a name="nil-array-reply"></a>

#### 空数组
RESP3有一个专门的数据类型用于表示[空值](#nulls)，而RESP2没有这样的类型。相反，由于历史原因，RESP2中的空值表示是通过预定的[Bulk Strings](#bulk-strings)和[arrays](#arrays)类型的形式。

空数组作为表示空值的一种替代方式存在。
例如，当 `BLPOP` 命令超时时，它返回一个空数组。

空数组的编码方式与长度为-1的数组相同，即：

    *-1\r\n

当Redis返回一个空数组时，客户端应该返回一个空对象而不是一个空数组。
这是为了区分空列表和其他条件（例如，`BLPOP`命令的超时条件）。

#### 数组中的空元素
数组的单个元素可以是[null bulk string](#null-bulk-strings)。
这在Redis的回复中用于表示这些元素缺失而不是空字符串。例如，使用`SORT`命令和`GET pattern`选项时，如果指定的键缺失，就会出现这种情况。

这是一个包含空元素的数组回复的例子：

    *3\r\n
    $5\r\n
    hello\r\n
    $-1\r\n
    $5\r\n
    world\r\n

上述情况中，第二个元素为空。
客户端库应该向调用者返回类似下面的内容：

    ["hello",nil,"world"]

<a name="null-reply"></a>

### 空值
空数据类型表示不存在的值。

Nulls的编码是下划线(`_`)字符，然后是CRLF终止符(`\r\n`)。
以下是Null的原始RESP编码：

    _\r\n

{{% alert title="Null Bulk String, Null Arrays and Nulls" color="info" %}}
由于历史原因，RESP2提供了两个特殊设计的值，用于表示Bulk String和Array的空值。
这种二重性从始至终都是协议本身增加的冗余，没有增加任何语义值。

在RESP3中引入了空类型，旨在修复这个错误。
{{% /alert %}}

<a name="boolean-reply">

### 布尔类型
RESP布尔值的编码方式如下所示：

#<t|f>\r\n

* 八角星字符 (`#`) 作为第一个字节。
* `t` 字符表示真值，`f` 字符表示假值。
* CRLF 终止符。

<a name="double-reply"></a>

## 双打
双 RESP 类型编码双精度浮点值。
Double的编码方式如下：

    ,[<+|->]<integral>[.<fractional>][<E|e>[sign]<exponent>]\r\n

* 逗号字符（`,`）作为第一个字节。
* 可选的加号（`+`）或减号（`-`）作为符号。
* 一个或多个十进制数字（`0`..`9`）作为无符号的十进制整数值。
* 可选的点号（`.`），后跟一个或多个十进制数字（`0`..`9`）作为无符号的十进制小数值。
* 可选的大写或小写字母 E（`E` 或 `e`），后跟一个可选的加号（`+`）或减号（`-`）作为指数的符号，最后以一个或多个十进制数字（`0`..`9`）作为无符号的十进制指数值。
* 回车换行（CRLF）结束符。

以下是数字1.23的编码：

    ,1.23\r\n

因为分数部分是可选的，因此十（10）的整数值可以被编码为整数或双精度数值。

    :10\r\n
    ,10\r\n

在这种情况下，Redis客户端应分别返回本机整数和双精度值，前提是实现语言支持这些类型。

正无穷大、负无穷大和NaN值的编码如下所示：

    ,inf\r\n
    ,-inf\r\n
    ,nan\r\n

<a name="big-number-reply"></a>

### 大数字
这种类型可以编码超出有符号64位整数范围的整数值。

大数使用以下编码：

    ([+|-]<number>\r\n

* 左括号字符 (`(`) 作为第一个字节。
* 可选的加号 (`+`) 或减号 (`-`) 作为符号。
* 一个或多个十进制数字 (`0`..`9`) 作为无符号的十进制值。
* 回车换行终止符。

大数字可以是正数或负数，但不能包含小数。
用拥有大数类型的编程语言编写的客户端库应返回大数。
当不支持大数时，客户端应返回一个字符串，并在可能的情况下向调用者发出信号，表示返回的是一个大整数（取决于客户端库使用的API）。

<a name="bulk-error-reply"></a>

### 批量错误
这种类型将[simple errors](#simple-errors)的目的与[bulk strings](#bulk-strings)的表达能力结合在一起。

    !<length>\r\n<error>\r\n

* `!`作为第一个字节。
* 一个或多个十进制数字（`0`..`9`）作为错误的长度，以字节为单位，作为无符号的十进制值。
* 回车换行终止符。
* 错误本身。
* 最后的回车换行。

作为一种惯例，错误以一个大写字母开头（以空格分隔的单词）来传达错误信息。

例如，错误"SYNTAX invalid syntax"由以下协议编码表示：

    !21\r\n
    SYNTAX invalid syntax\r\n

(raw RESP编码分为多行以增加可读性)。

<a name="verbatim-string-reply">

### 逐字字符串
这种类型与[bulk string](#bulk-strings)类似，但还提供了有关数据编码的提示。

一个原样字符串的 RESP 编码如下所示：

    =<length>\r\n<encoding>:<data>\r\n

* 以等号（`=`）作为第一个字节。
* 一个或多个十进制数字（`0`..`9`）作为字符串的总长度，以字节为单位，作为一个无符号的十进制值。
* CRLF 终止符。
* 精确地三（3）个字节表示数据的编码。
* 冒号（`:`）字符分隔编码和数据。
* 数据。
* 最后一个 CRLF。

    =15\r\n
    txt:Some string\r\n

一些客户端库可能会忽略这种类型和字符串类型之间的差异，并在两种情况下返回本机字符串。
但是，交互式客户端，如命令行界面（例如[`redis-cli`](/docs/manual/cli)），可以使用此类型，并且知道它们的输出应该原样呈现给人类用户，并且不对字符串进行引号处理。

例如，Redis命令`INFO`输出的报告中包含换行符。
使用RESP3时，`redis-cli`正确地显示它，因为它被发送为原样字符串回复（其三个字节为“txt”）。
然而，在使用RESP2时，`redis-cli`是硬编码的，以确保正确地显示给用户的`INFO`命令。

<a name="map-reply"></a>

### 地图
RESP映射将一组键值对编码，即字典或哈希。

    %<number-of-entries>\r\n<key-1><value-1>...<key-n><value-n>

* 百分号字符（`%`）作为第一个字节。
* 一个或多个十进制数字（`0`..`9`）作为条目（或键值对）在地图中的数量，作为一个无符号的十进制值。
* CRLF终止符。
* 对于地图中的每个键和值，还有两种额外的RESP类型。

例如，下面的JSON对象：

    {
        "first": 1,
        "second": 2
    }

可以这样将其编码为RESP：

    %2\r\n
    +first\r\n
    :1\r\n
    +second\r\n
    :2\r\n

（原始的RESP编码被分成多行以提高可读性）。

映射的键和值都可以是RESP的任何类型。

Redis客户端应返回其语言提供的惯用字典类型。
然而，低级编程语言（如C语言，例如）可能会返回一个数组，同时附带类型信息，以告诉调用者它是一个字典。

{{% alert title="Map pattern in RESP2" color="info" %}}
RESP2没有地图类型。
在RESP2中，地图以数组的形式表示，其中每个元素都是一个键值对。
每个键值对是一个包含两个元素的数组，分别为键和值。
{{% /alert %}}

<a name="set-reply"></a>

### 集合
集合有点像 [数组](#数组)，但是是无序的并且只应包含唯一元素。

RESP设置的编码是：

    ~<number-of-elements>\r\n<element-1>...<element-n>

* 第一个字节为波浪号（`~`）。
* 一个或多个十进制数字（`0`..`9`）作为集合元素数量的无符号十进制值。
* CRLF 终止符。
* 为集合中每个元素添加一个额外的 RESP 类型。

如果客户端的编程语言中存在原生的集合类型，应当返回原生的集合类型。
如果没有原生的集合类型，可以使用配合类型信息的数组（例如，在 C 语言中）。

<a name="push-event"></a>

### 推送
RESP的推送包含带外数据。
它们是协议请求-响应模型的例外，并为连接提供普通的**推送模式**。

推送事件的编码方式与[数组](#数组)类似，唯一的区别在于它们的第一个字节：

    ><number-of-elements>\r\n<element-1>...<element-n>

* 作为第一个字节的大于号 (`>`)。
* 一个或多个十进制数字 (`0`..`9`)，作为消息中元素的数量，作为无符号的十进制值。
* CRLF 终止符。
* 为推送事件的每个元素添加一个额外的 RESP 类型。

推送的数据可以出现在RESP的各种数据类型之前或之后，但不会出现在其中。
这意味着客户端不会在响应中间找到推送数据，例如在一个映射回复中间。
这也意味着推送的数据可以出现在命令的回复之前或之后，也可以单独出现（不调用任何命令）。

客户端应该通过调用实现其处理推送数据的回调来对推送做出反应。

## 客户端握手
新的RESP连接应该通过调用`HELLO`命令开始会话。
这种做法实现了两个目标：

1. 它允许服务器与 RESP2 版本保持向后兼容，这在 Redis 中是必需的，以使协议转换到版本 3 更加平滑。
2. `HELLO` 命令返回有关服务器和客户端可以用于不同目标的协议的信息。

"HELLO" 命令具有以下高级语法:

    HELLO <protocol-version> [optional-arguments]

命令的第一个参数是我们希望连接设置的协议版本。
默认情况下，连接在 RESP2 模式下启动。
如果我们指定了一个太大并且服务器不支持的连接版本，它应该回复一个"-NOPROTO"错误。示例：

    Client: HELLO 4
    Server: -NOPROTO sorry, this protocol version is not supported.
    
在这种情况下，客户端可以尝试使用较低的协议版本进行重试。

同样，客户端可以轻松检测到只能使用RESP2协议进行通信的服务器：

    Client: HELLO 3
    Server: -ERR unknown command 'HELLO'

客户端可以继续使用RESP2与服务器进行通信。

请注意，即使协议版本被支持，`HELLO`命令也可能返回错误，在RESP2模式下不执行任何操作。
例如，在命令的可选`!AUTH`子句中使用无效的身份验证凭据时：

    Client: HELLO 3 AUTH default mypassword
    Server: -ERR invalid password
    (the connection remains in RESP2 mode)

对 `HELLO` 命令的成功回复是一个地图回复。
回复中的信息部分取决于服务器，但某些字段对所有 RESP3 实现都是必需的：
* **server**: "redis" （或其他软件名称）。
* **version**: 服务器的版本。
* **proto**: RESP 协议的最高支持版本。

在Redis的RESP3实现中，还会发出以下字段：

* **id**: 连接的标识符(ID)。
* **mode**: "standalone"（独立模式）, "sentinel"（哨兵模式）或"cluster"（集群模式）。
* **role**: "master"（主节点）或"replica"（从节点）。
* **modules**: 以字符串数组形式列出的已加载模块。

## 发送命令到Redis服务器
既然您已经熟悉了RESP序列化格式，那么您可以使用它来帮助编写Redis客户端库。
我们可以进一步指定客户端和服务器之间的交互方式：

客户端向Redis服务器发送仅由批量字符串（bulk string）组成的[数组](#arrays)。
Redis服务器向客户端回复，发送任何有效的RESP数据类型作为回复。

所以，举个例子，一个典型的互动可能是下面这样的。

客户端发送命令'LLEN mylist'获取存储在键_mylist_处列表的长度。
然后服务器回复一个整数回复，如以下示例（`C:`表示客户端，`S:`表示服务器）。

    C: *2\r\n
    C: $4\r\n
    C: LLEN\r\n
    C: $6\r\n
    C: mylist\r\n

    S: :48293\r\n

通常，为了简单起见，我们使用换行符来分隔协议的不同部分，但实际交互时客户端作为一个整体发送`*2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n`。

## 多个命令和管道
客户端可以使用同一个连接来发出多个命令。
支持流水线处理，因此客户端可以使用单个写操作发送多个命令。
客户端可以跳过读取回复并继续发送命令。
所有的回复都可以在最后读取。

有关更多信息，请参阅[Pipelining](/topics/pipelining)。

## 内联命令
有时候你可能需要向Redis服务器发送一个命令，但只有`telnet`可用。
尽管Redis协议很容易实现，但它并不适用于交互式会话，并且`redis-cli`可能并不总是可用的。
因此，Redis还接受以__内联命令__格式的命令。

以下示例演示了使用内联命令进行服务器/客户端交互（服务器聊天以 `S:` 开始，客户端聊天以 `C:` 开始）：

    C: PING
    S: +PONG

这里是服务器返回整数的内联命令的另一个示例：

    C: EXISTS somekey
    S: :0

基本上，要发出内联命令，您需要在Telnet会话中书写以空格分隔的参数。
由于没有命令以`*`（RESP数组的标识字节）开头，Redis会检测到此情况并解析您的内联命令。

## Redis协议高性能解析器

虽然Redis协议具有可读性强且易于实现的特点，但其实现可以展现出类似于二进制协议的性能。

RESP使用前缀长度来传输批量数据。
这样就不需要扫描有效负载中的特殊字符（与解析JSON不同）。
出于同样的原因，不需要对有效负载进行引用和转义。

读取聚合类型（例如，批量字符串或数组）的长度可以使用执行每个字符的单个操作的代码来处理，同时还会扫描 CR 字符。

在C语言中的示例代码如下：
```c
#include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
```

```c
#include <stdio.h>

int main(void) {
    unsigned char *p = "$123\r\n";
    int len = 0;

    p++;
    while(*p != '\r') {
        len = (len*10)+(*p - '0');
        p++;
    }

    /* Now p points at '\r', and the len is in bulk_len. */
    printf("%d\n", len);
    return 0;
}
```

在第一个CR被识别后，可以跳过该CR和其后的LF字符而不进行进一步处理。
然后，可以使用单个读取操作读取批量数据，而不检查任何负载。
最后，剩下的CR和LF字符被丢弃，不进行额外的处理。

虽然Redis协议在性能上与二进制协议相当，但在大多数高级语言中实现起来更加直观，从而降低客户端软件中的错误数量。

# Redis客户端开发者的提示

* 为了测试目的，使用[Lua的类型转换](/topics/lua-api#lua-to-resp3-type-conversion)来使Redis回复所需的任何RESP2/RESP3。
  例如，可以按如下方式生成一个RESP3双精度数：
  ```
  EVAL "return { double = tonumber(ARGV[1]) }" 0 1e0
  ```

