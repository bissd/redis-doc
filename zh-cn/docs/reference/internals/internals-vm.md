---
title: "虚拟内存（已弃用）"
linkTitle: "虚拟内存"
weight: 1
description: Redis虚拟内存系统的描述在2.6版本中已弃用。此文档仅供历史参考。
aliases:
  - /topics/internals-vm
  - /topics/virtual-memory
---

**注意：此文档是Redis的创建者Salvatore Sanfilippo在Redis开发初期（约2010年）撰写的。 自Redis 2.6版本起，虚拟内存已被弃用，因此此文档仅供历史参考。**

这份文档详细介绍了 Redis 虚拟内存子系统在 Redis 2.6 之前的内部工作机制。目标读者并不是最终用户，而是那些希望了解或修改虚拟内存实现的程序员。

键与值：被交换的是什么？
---

VM子系统的目标是将Redis对象从内存转移到磁盘以释放内存。这是一个非常通用的命令，但具体来说，Redis只转移与值相关联的对象。为了更好地理解这个概念，我们将使用DEBUG命令展示一个保存值的键在Redis内部的视角。

    redis> set foo bar
    OK
    redis> debug object foo
    Key at:0x100101d00 refcount:1, value at:0x100101ce0 refcount:1 encoding:raw serializedlength:4

如你从上面的输出中可以看到，Redis的顶级哈希表将Redis对象（键）映射到其他Redis对象（值）。虚拟内存只能将值交换到磁盘上，与键关联的对象总是在内存中：这种权衡保证了非常好的查找性能，因为Redis虚拟内存的主要设计目标之一是在常用数据集的部分适合内存时，具有与禁用虚拟内存的Redis相似的性能。

交换值的内部表现如何
---

当对象被交换出时，在哈希表条目中发生的情况如下：

* 键继续持有一个表示键的 Redis 对象。
* 值被设置为 NULL。

所以你可能想知道我们将给定值（与给定键相关联）被替换出的信息存储在哪里。就在键对象中！

以下是Redis对象结构_robj_的示例：

    /* The actual Redis Object */
    typedef struct redisObject {
        void *ptr;
        unsigned char type;
        unsigned char encoding;
        unsigned char storage;  /* If this object is a key, where is the value?
                                 * REDIS_VM_MEMORY, REDIS_VM_SWAPPED, ... */
        unsigned char vtype; /* If this object is a key, and value is swapped out,
                              * this is the type of the swapped out object. */
        int refcount;
        /* VM fields, this are only allocated if VM is active, otherwise the
         * object allocation function will just allocate
         * sizeof(redisObject) minus sizeof(redisObjectVM), so using
         * Redis without VM active will not have any overhead. */
        struct redisObjectVM vm;
    } robj;

您可以看到VM有几个字段。其中最重要的是_storage_，可以是以下值之一：

* `REDIS_VM_MEMORY`：相关的值在内存中。
* `REDIS_VM_SWAPPED`：相关值已被交换，哈希表的值条目仅设置为NULL。
* `REDIS_VM_LOADING`：该值被交换到磁盘上，条目为NULL，但有一个任务将对象从交换区加载到内存中（仅在线程化虚拟模块激活时使用此字段）。
* `REDIS_VM_SWAPPING`：该值在内存中，条目是指向实际Redis对象的指针，但有一个I/O任务以便将该值传输到交换文件中。

如果一个对象被交换到磁盘上（`REDIS_VM_SWAPPED`或`REDIS_VM_LOADING`），我们如何知道它存储在哪里，它的类型是什么等等？这很简单：`_vtype_`字段被设置为Redis对象交换前的原始类型，而`_vm_`字段（这是一个_redisObjectVM_结构）保存有关对象位置的信息。这是这个附加结构的定义：

    /* The VM object structure */
    struct redisObjectVM {
        off_t page;         /* the page at which the object is stored on disk */
        off_t usedpages;    /* number of pages used on disk */
        time_t atime;       /* Last access time */
    } vm;

您可以看到，结构包含了对象在交换文件中所在的页面，使用的页面数量以及对象的最后访问时间（这对于选择一个好的交换对象的算法非常有用，因为我们希望将很少访问的对象转移到磁盘上）。

正如您所见，尽管其他所有字段都使用旧的Redis对象结构中未使用的字节（由于自然内存对齐的原因，我们有一些空闲位），但_vm_字段是新的，并且确实使用了额外的内存。即使在VM禁用时，我们是否应该支付这样的内存成本呢？不！这是创建一个新的Redis对象的代码：

    ... some code ...
            if (server.vm_enabled) {
                pthread_mutex_unlock(&server.obj_freelist_mutex);
                o = zmalloc(sizeof(*o));
            } else {
                o = zmalloc(sizeof(*o)-sizeof(struct redisObjectVM));
            }
    ... some code ...

正如你所看到的，如果虚拟内存系统未启用，我们将只分配 `sizeof(*o)-sizeof(struct redisObjectVM)` 的内存。鉴于 _vm_ 字段位于对象结构的最后，并且如果禁用 VM，则不会访问这些字段，因此我们是安全的，Redis 在没有 VM 的情况下不会增加内存开销。

Swap 文件
---

为了理解虚拟内存子系统的工作原理，下一步是了解对象在交换文件中的存储方式。好消息是，这不是一种特殊的格式，我们只是使用与.rdb文件中存储对象相同的格式，这些是由Redis使用`SAVE`命令产生的常规转储文件。

交换文件由一定数量的页面组成，其中每个页面的大小为一定数量的字节。这些参数可以在 redis.conf 中进行更改，因为不同的 Redis 实例可能需要不同的值以获得更好的工作效果：它取决于您存储在其中的实际数据。以下是默认值：

    vm-page-size 32
    vm-pages 134217728

Redis 在内存中存储了一个“位图”（一连串的位，每一个位代表磁盘上交换文件的一页）：如果某个位被设置为 1，表示该页已被使用（有一些 Redis 对象存储于此），而如果对应的位是零，则表示该页为空闲。

采用这种将位图（调用页面表）存储在内存中的方法对性能来说是巨大的优势，而且所使用的内存很小：我们只需要为磁盘上的每个页面使用1个比特位。例如，在下面的示例中，每个页面为32字节（4GB交换文件）的134217728个页面只使用16MB的RAM作为页面表。

从内存转移到交换区的对象

为了将一个对象从内存转移到磁盘，我们需要执行以下步骤（假设是非线程虚拟机，只是一个简单的阻塞方法）：

* 找出需要多少页用于存储此对象在交换文件中。这个简单地通过调用函数`rdbSavedObjectPages`来实现，该函数返回磁盘上对象使用的页数。请注意，此函数不会复制.rdb保存代码，这只是为了了解对象在保存到磁盘后长度是多少，我们使用打开/dev/null并将对象写入其中的技巧，最后调用`ftello`以检查所需的字节数量。我们基本上是将对象保存在一个虚拟非常快的文件中，即/dev/null。
* 现在我们知道交换文件需要多少页之后，我们需要在交换文件中找到这个数量的连续空闲页。这个任务由`vmFindContiguousPages`函数完成。正如你所想，如果交换空间已满，或者碎片化严重以至于我们无法轻松找到所需数量的连续空闲页，这个函数可能会失败。当发生这种情况时，我们只是中止对象的交换，该对象将继续留在内存中。
* 最后，我们可以通过调用`vmWriteObjectOnSwap`函数将对象写入磁盘上的指定位置。

由于对象被正确地写入交换文件中，它会从内存中释放，与其关联的键的存储字段被设置为`REDIS_VM_SWAPPED`，并且使用的页面会在页表中标记为已使用。

加载对象回到内存中
---

从交换区加载对象到内存中更简单，因为我们已经知道对象的位置和它使用了多少页。我们还知道对象的类型（加载函数需要知道这个信息，因为在磁盘上没有头文件或其他关于对象类型的信息），但这存储在上面已经看到的关联密钥的_vtype_字段中。

调用函数`vmLoadObject`传递与我们想要加载回来的值对象相关联的键对象就足够了。该函数还会处理键的存储类型（将其设置为`REDIS_VM_MEMORY`），在页表中标记页面为释放状态，等等。

函数的返回值是已加载的 Redis 对象本身，我们需要将其再次设置为主哈希表中的值（而不是在将对象指针替换为 NULL 值时放入的空值）。

阻塞虚拟机的工作原理
---

现在我们已经准备好了所有的构建模块，可以描述阻塞式虚拟机的工作原理。首先，关于配置的一个重要细节，在Redis中启用阻塞式虚拟机，必须将`server.vm_max_threads`设置为零。
我们稍后将看到关于线程化虚拟机中如何使用最大线程数信息的方法，现在只需知道当将其设置为零时，Redis会恢复到完全阻塞的虚拟机。

我们还需要介绍另一个重要的虚拟机参数，即 `server.vm_max_memory`。该参数非常重要，因为它用于触发交换操作：只有当Redis使用的内存超过最大内存设置时，Redis才会尝试进行对象交换，否则就没有必要进行交换，因为我们已经匹配了用户请求的内存使用情况。

阻塞虚拟机交换

内存到磁盘的对象交换在cron函数中发生。该函数过去每秒调用一次，在最近的Redis版本中，它在每100毫秒（也就是每秒10次）调用一次。
如果此函数检测到我们的内存不足，即内存使用量大于vm-max-memory设置，它将在循环中调用函数vmSwapOneObect将对象从内存转移到磁盘。此函数只需要一个参数，如果为0，将以阻塞方式交换对象，否则如果为1，则使用I/O线程。在阻塞方案中，我们只需将其参数设为零即可。

vmSwapOneObject方法执行以下步骤：

*以顺序检查键空间，以找到一个合适的交换候选者（稍后会看到什么是一个合适的交换候选者）。
*关联的值以阻塞方式传输到磁盘。
*设置键存储字段为`REDIS_VM_SWAPPED`，同时将对象的_vm_字段设置为正确的值（对象被交换的页索引和用于交换它的页数）。
*最后释放值对象，并将哈希表的值条目设置为NULL。

一直重复调用该函数，直到出现以下情况之一：没有更多的对象可以交换，因为交换文件已满或几乎所有对象已经传输到磁盘上，或者内存使用已经达到了vm-max-memory参数。

当我们内存不足时需要交换哪些值？

理解什么是适合交换的良好候选对象并不太难。随机采样了一些对象，并为每个对象计算了它们的交换能力，具体如下：

    swappability = age*log(size_in_memory)

年龄是键未被请求的秒数，而内存中的大小是内存中对象所使用的快速估计（以字节为单位）。因此，我们尝试交换很少访问的对象，并尝试交换较大的对象而不是较小的对象，但后者是一个较不重要的因素（因为使用了对数函数）。这是因为我们不希望较大的对象被频繁地交换进出，因为较大的对象需要更多的I/O和CPU来传输。

阻止VM加载
---

如果请求针对一个与已交换出的对象关联的键的操作，会发生什么？例如，Redis可能会恰好处理以下命令：

    GET foo

如果 `foo` 键的值对象被交换，我们需要在处理操作之前将其重新加载到内存中。在 Redis 中，键查找过程是集中在 `lookupKeyRead` 和 `lookupKeyWrite` 函数中的。这两个函数用于实现访问键空间的所有 Redis 命令，因此我们有一个代码中的单一点来处理从交换文件加载键到内存中的操作。

所以发生了以下情况：

 * 用户调用一个命令，其参数是交换后的键
 * 命令的实现调用查找函数
 * 查找函数在顶级哈希表中搜索键。如果与请求的键关联的值已交换（我们可以通过检查键对象的_storage_字段来了解），我们会以阻塞的方式将其重新加载到内存中，然后返回给用户。

这很直接，但是随着线程的增加，事情会变得更加有趣。从阻塞虚拟机的角度来看，唯一真正的问题是使用另一个进程保存数据集，也就是处理`BGSAVE`和`BGREWRITEAOF`命令。

在虚拟机处于活动状态时进行后台保存

默认的Redis将数据持久化到磁盘的方式是使用子进程创建.rdb文件。Redis通过调用fork()系统调用来创建一个子进程，该子进程拥有与内存数据集完全相同的副本，因为fork会复制整个程序的内存空间（实际上，由于一种称为写时复制的技术，父子进程之间共享内存页，所以fork()调用不需要太多内存）。

在子进程中，我们拥有在某一特定时间点的数据集的副本。客户端发出的其他命令只会由父进程处理，不会修改子进程的数据。

The child process will just store the whole dataset into the dump.rdb file and finally will exit. But what happens when the VM is active? Values can be swapped out so we don't have all the data in memory, and we need to access the swap file in order to retrieve the swapped values. While child process is saving the swap file is shared between the parent and child process, since:

子进程只会将整个数据集存储到dump.rdb文件中，最后退出。但是当虚拟内存（VM）处于活动状态时会发生什么呢？值可能被交换出去，因此我们无法将所有数据都保存在内存中，需要访问交换文件以检索被交换的值。在子进程保存交换文件时，交换文件是由父进程和子进程共享的，因为：

* 父进程需要访问交换文件，以便在针对交换出的值的操作中将值加载回内存。
* 子进程需要访问交换文件，以便在将数据集保存到磁盘时检索完整的数据集。

为了避免在两个进程同时访问同一个交换文件时出现问题，我们做了一个简单的操作，即在后台保存进行中时不允许父进程中的值进行换出。这样，两个进程都将以只读方式访问交换文件。这种方法存在一个问题，即当子进程保存数据时，即使Redis使用的内存超过了最大内存参数的限制，也无法在交换文件中传输新值。通常情况下，这不会成为问题，因为后台保存将在很短的时间内结束，如果仍然需要，一部分值将尽快在磁盘上进行交换。

该方案的一个替代方案是启用附加写文件，只有在使用`BGREWRITEAOF`命令执行日志重写时才会出现这个问题。

阻塞式虚拟机的问题

阻塞虚拟机的问题在于...它会阻塞 :)
对于批处理活动中使用 Redis 来说这不是个问题，但对于实时使用来说，Redis 的一个好处就是低延迟。当客户端访问一个被交换出的值时，或者当 Redis 需要交换出值时，阻塞虚拟机会产生不良的延迟行为，此时其他客户端将无法服务。

键的交换应在后台进行。类似地，当一个客户端访问被交换出的值时，其他访问内存中的值的客户端应尽可能快地提供服务，就像禁用虚拟机时一样。只有处理已交换出的键的客户端会有延迟。

所有这些限制要求实现一个非阻塞的虚拟机。

线程化虚拟机
---

转换阻塞虚拟机为非阻塞虚拟机主要有三种方法：
1. 一种方式是显而易见的，但在我看来并不是一个好主意，那就是将Redis本身转换为线程服务器：如果每个请求都由不同的线程自动服务，其他客户端就不需要等待被阻塞的请求。Redis运行速度快，支持原子操作，没有锁，并且只有1万行代码，正因为它是单线程的，所以这对我来说不是一个选项。
2. 使用非阻塞I/O对交换文件进行操作。毕竟，你可以认为Redis已经基于事件循环，为什么不以非阻塞的方式处理磁盘I/O呢？我放弃了这种可能性，原因有两个。一方面，非阻塞文件操作与套接字不同，会导致兼容性问题。它不仅仅是调用select，还需要使用特定于操作系统的东西。另一个问题是，I/O只是处理虚拟内存所消耗的时间的一部分，另一个重要的方面是CPU用于对交换文件进行编码/解码。因此我选择了第三种方法，即...
3. 使用I/O线程，即一组处理交换I/O操作的线程池。这是Redis虚拟内存使用的方法，下面我们详细介绍其工作原理。

I/O 线程
---

以下是分线程虚拟机的设计目标，按重要性排序：

- 简单实现，几乎没有竞态条件，简单的锁定，虚拟机系统与Redis代码基本分离。
- 良好的性能，内存中的值对于客户端访问无需锁定。
- 在 I/O 线程中对对象进行解码/编码的能力。

上述目标导致了一种实现方式，其中Redis主线程（为实际客户端服务的线程）和I/O线程通过一个带有单个互斥锁的作业队列进行通信。
基本上，当主线程需要在后台由某个I/O线程完成一些工作时，它会将I/O作业结构推入“server.io_newjobs”队列中（即一个链接列表）。如果没有活动的I/O线程，就会启动一个线程。此时，某个I/O线程将处理I/O作业，并将处理结果推送到“server.io_processed”队列中。I/O线程将使用UNIX管道向主线程发送一个字节，以表示已处理完新的作业并且结果已准备好进行处理。

这是 `iojob` 结构的样子：

    typedef struct iojob {
        int type;   /* Request type, REDIS_IOJOB_* */
        redisDb *db;/* Redis database */
        robj *key;  /* This I/O request is about swapping this key */
        robj *val;  /* the value to swap for REDIS_IOREQ_*_SWAP, otherwise this
                     * field is populated by the I/O thread for REDIS_IOREQ_LOAD. */
        off_t page; /* Swap page where to read/write the object */
        off_t pages; /* Swap pages needed to save object. PREPARE_SWAP return val */
        int canceled; /* True if this command was canceled by blocking side of VM */
        pthread_t thread; /* ID of the thread processing this entry */
    } iojob;

只有三种类型的工作可以由 I/O 线程执行（该类型由结构体的 `type` 字段指定）：

* `REDIS_IOJOB_LOAD`：从交换空间将与给定键相关联的值加载到内存中。交换文件中的对象偏移量为`page`，对象类型为`key->vtype`。此操作的结果将填充结构的`val`字段。
* `REDIS_IOJOB_PREPARE_SWAP`：计算为了将`val`指向的对象保存到交换空间中而需要的页面数量。此操作的结果将填充字段`pages`。
* `REDIS_IOJOB_DO_SWAP`：将`val`指向的对象转移到交换文件中的页面偏移量为`page`的位置。

主线程仅委派上述三个任务。其余的任务由I/O线程自己处理，例如在交换文件页表中查找适当的空闲页范围（这是一项快速操作），决定交换哪个对象，修改Redis对象的存储字段以反映值的当前状态。

非阻塞虚拟机是阻塞虚拟机的概率增强。

现在我们有一种方式可以请求处理缓慢的虚拟机操作的后台作业。如何将此添加到主线程完成的其他工作中？尽管阻塞虚拟机在查找对象时会意识到对象已经被交换出去了，但对我们来说，这已经太晚了：在C语言中，要在命令的执行过程中开始一个后台作业，离开函数，并在I/O线程完成我们请求的工作后重新进入同一点的计算（也就是说，没有协程或类似）并不容易。

幸运的是，有一种简单得多的方法来实现这一点。我们喜欢简单的事情：基本上将VM实现视为阻塞的一个，但添加了一种优化（利用我们能够执行的非阻塞VM操作），以使阻塞的可能性非常小。

这是我们所做的事情：

* 每当客户端发送命令给我们时，在执行命令之前，我们检查命令的参数向量，以查找交换的键。因为Redis命令格式非常简单，我们知道每个命令都有哪些参数是键。
* 如果我们发现请求的命令中至少有一个键在磁盘上被交换了，我们会阻塞客户端而不是真正执行命令。对于与请求的键关联的每个被交换的值，我们会创建一个I/O任务，将这些值重新加载到内存中。主线程继续执行事件循环，不关心被阻塞的客户端。
* 同时，I/O线程正在加载内存中的值。每当一个I/O线程完成加载一个值时，它会使用一个UNIX管道向主线程发送一个字节。管道文件描述符在主线程的事件循环中关联了一个可读事件，这就是函数vmThreadedIOCompletedJob。如果该函数检测到所有被阻塞客户端所需的值都已加载完毕，客户端将被重新启动并调用原始命令。

所以你可以把它看作是一个被阻塞的虚拟机，几乎总是在内存中保存着正确的密钥，因为我们会暂停正在执行关于被交换出的值的命令的客户端，直到这些值被加载进来。

如果检查参数是否为键的函数以某种方式失败，那么没有问题：查找函数将看到给定的键与一个被交换出的值相关联，并会阻止加载它。因此，当无法预测哪些键被触及时，我们的非阻塞虚拟机将恢复到阻塞状态。

就`SORT`命令与`GET`或`BY`选项一起使用的情况来说，事先很难知道哪些键将被请求，因此至少在第一次实现中，`SORT BY/GET`会采用阻塞的VM实现。

阻止使用交换的密钥的客户端
---

如何阻止客户端？ 在基于事件循环的服务器中，暂停一个客户端非常简单。我们所做的就是取消其读取处理程序。有时我们会做一些不同的事情（例如对于BLPOP），即只是将客户端标记为已阻止，但不处理新数据（只是将新数据累积到输入缓冲区中）。

中止I/O作业
---

有关我们的阻塞和非阻塞虚拟机之间的交互存在一个难以解决的问题，即，如果一个阻塞操作和一个同时对同一关键字“感兴趣”的非阻塞操作同时开始，会发生什么？

例如，当执行SORT BY时，一些键会被排序命令以阻塞的方式加载。与此同时，另一个客户端可能会通过简单的_GET key_命令请求相同的键，这将触发创建一个后台加载键的I/O作业。

处理这个问题的唯一简单方法是能够在主线程中终止I/O作业，这样，如果我们想以阻塞方式加载或交换的键处于“REDIS_VM_LOADING”或“REDIS_VM_SWAPPING”状态（即存在与此键相关的I/O作业），我们可以终止与该键相关的I/O作业，然后继续执行我们希望执行的阻塞操作。

这并不像它那样简单。在给定的时刻，一个I/O作业可以在以下三个队列中的任意一个中。

* server.io_newjobs：该作业已添加到队列中，但没有线程处理。
* server.io_processing：该作业正在被I/O线程处理。
* server.io_processed：该作业已经完成处理。
能够终止I/O作业的函数是`vmCancelThreadedIOJob`，下面是其功能：
* 如果作业在新作业队列中，那很简单，只需从队列中移除iojob结构即可，因为没有线程正在执行任何操作。
* 如果作业在处理队列中，表示有一个线程正在操作我们的作业（可能还有相关联的对象！）。我们唯一能做的就是以*阻塞方式*等待该项移动到下一个队列中。幸运的是，这种情况很少发生，所以不会影响性能。
* 如果作业在已处理队列中，我们只需将其标记为“已取消”，即在iojob结构中将`canceled`字段设置为1。处理已完成作业的函数将忽略并释放该作业，而不是真正处理它。

有问题吗？
---

这份文档并不完整，唯一能获得全貌的办法是阅读源代码，但它应该是一个很好的介绍，以便使代码审查/理解变得简单得多。

如果对这个页面有任何疑问，请留下评论，我会尽力解答，并可能将答案整合到这个文档中。
