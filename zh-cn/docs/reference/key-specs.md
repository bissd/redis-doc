---
 title: "Command key 规范"
 linkTitle: "Command key 规范"
 weight: 3
 description: 什么是command key规范以及如何在客户端中使用它们
 aliases:
   - /topics/key-specs
---

许多 Redis 命令接受键名作为输入参数。
`COMMAND`（和 `COMMAND INFO`）的回复的第9个元素是一个包含命令键规范的数组。

一个_key specification_描述了从给定命令的参数中提取一个或多个键名的规则。
与 Redis 7.0 之前采用的_first key_、_last key_ 和 _step_ 方案相比，key specifications 提供了一种强大且灵活的机制。
在引入这些规范之前，Redis 客户端无法以简单的编程方式提取所有命令的键名。

在使用诸如`EVAL`和`ZUNIONSTORE`的命令时，集群感知的Redis客户端必须在代码中硬编码提取键的逻辑，这些命令依赖于_numkeys_参数或`SORT`及其多个子句。
另外，可以使用`COMMAND GETKEYS`来实现类似的提取效果，但延迟较高。

一个Redis客户端不必支持键的规范。
它可以继续使用传统的“第一个键”、“最后一个键”和“步长”方案，同时保持不变的[_movablekeys_标志](/commands/command#flags)。

然而，实现键规范支持的Redis客户端可以整合大部分键提取逻辑。
即使客户端遇到一个不熟悉的键规范类型，它总是可以回退到 `COMMAND GETKEYS` 命令。

也就是说，大多数集群感知客户端只需要一个键名来执行正确的命令路由，因此尽管一个命令具有一个不熟悉的规格，客户端仍然可以使用其其他规格。

主要规格是具有以下键的地图：

1. **begin_search:**: 提取密钥的起始索引。
2. **find_keys:** 用于识别与BS相关的密钥的规则。
3. **notes**: 关于此密钥规范的注释，如果有的话。
4. **flags**: 指示数据访问类型。

## 开始搜索

规范的 _begin\_search_ 值告知客户端提取的起始位置。
该值是一个映射。
有三种类型的 `begin_search`：

1. **index：**关键名参数从常数索引开始。
2. **keyword：**关键名在特定关键字（token）之后开始。
3. **unknown：**未知类型的说明 - 有关更多详细信息，请参阅[不完整标志节](#incomplete)。

### 索引

`begin_search`的_index_类型表示输入键出现在固定的索引位置。
它是在_spec_键下的一个映射，只有一个键：

1. **index:** 客户端应从中开始提取关键名称的基于0的索引。

### 关键词

`begin_search` 的关键字类型表示在关键字名称参数之前存在一个字面标记。
它是在 _spec_ 下的一个包含两个键的映射：

1. **keyword：**用于标记关键名称参数开头的关键词（令牌）。
2. **startfrom：**一个索引，表示客户端应该从其中开始搜索的参数数组位置。
   这可以是一个负值，表示搜索应该从参数数组的末尾开始，以相反的顺序。
   例如，_ -2_ 的意思是从倒数第二个参数开始逆向搜索。

更多以_关键词_搜索类型为例的示例包括：

* `SET` 带有类型为 _index_ 值为 _1_ 的 `begin_search` 规范。
* `XREAD` 带有类型为 _keyword_ 的 `begin_search` 规范，关键字和 `startfrom` 分别为 _"STREAMS"_ 和 _1_。
* `MIGRATE` 带有类型为 _keyword_ 的 `start_search` 规范，关键字为 _"KEYS"_ 和 _-2_ 的值。

## find_keys


"find_keys"值是一个关键指定的属性，它告诉客户端如何继续搜索关键字名称。
"find_keys"有三种可能的类型：

1. **range：** 键停在特定索引或相对于最后一个参数的位置。
2. **keynum：** 附加参数指定输入键的数量。
3. **unknown：** 未知类型的规范 - 请参阅更多详细信息，请参阅[不完整标志部分](#incomplete)。

### 范围

`find_keys`的_range_类型是_spec_键下的映射，有三个键：

1. **lastkey：**对于相对于`begin_search`的最后一个关键字参数的索引。
   这可以是一个负值，此时它不是相对的。
   例如，_ -1_ 表示提取关键字直到最后一个参数，_ -2_ 表示提取关键字直到倒数第二个参数，依此类推。
2. **keystep：**在找到一个关键字后，应跳过的参数数。
3. **limit：**如果 _lastkey_ 的值为 _-1_，我们使用 _limit_ 来按因数停止搜索。
   _0_ 和 _1_ 表示没有限制。
   _2_ 表示剩余参数的一半，_3_ 表示三分之一，依此类推。

### keynum

`find_keys` 的 _keynum_ 类型是在 _spec_ 键下的一个具有三个键的映射：

* **keynumidx:** 相对于`begin_search`的索引，指定包含键数的参数。
* **firstkey:** 相对于`begin_search`的索引，指定第一个键。
  通常是_keynumidx_后面的下一个参数，其值比_keynumidx_大一。
* **keystep:** 在找到一个键后，应该跳过的参数数量，以找到下一个键。


* `SET` 命令的范围是 0、1 和 0。
* `MSET` 命令的范围是 -1、2 和 0。
* `XREAD` 命令的范围是 -1、1 和 2。
* `ZUNION` 命令的 `start_search` 类型为索引，值为 1，而 `find_keys` 的类型为 `keynum`，值有 0、1 和 1。
* [`AI.DAGRUN`](https://oss.redislabs.com/redisai/master/commands/#aidagrun) 命令的 `start_search` 类型为关键字，值有 "LOAD" 和 1，而 `find_keys` 的类型为 `keynum`，值有 0、1 和 1。

**注意：**
这并不是一个完美的解决方案，因为模块的编写者可以想出任何方法。
然而，这个机制应该能够对绝大多数命令提取关键名称参数。

## 笔记

非明显关键规格注意事项（如果适用）。

## 标志

键值规范可以有附加的标志，这些标志提供关于键的更多细节。
这些标志分为三组，如下所述。

### 访问类型标志

以下标志声明命令访问键值或元数据时所使用的访问类型。
键的元数据包括LRU / LFU计数器、类型和基数。
这些标志与发送给客户端的回复无关。

每个关键规范都精确地拥有以下标识之一：

* **RW：** 读写标志。
  该命令修改了键的值或其元数据中存储的数据。
  这个标志用于标记不是明确的删除、覆盖或只读操作的每个操作。
* **RO：** 只读标志。
  该命令只读取键的值（尽管不一定返回它）。
* **OW：** 覆盖标志。
  该命令覆盖键的值中存储的数据。
* **RM：** 删除标志。
  该命令删除键。
 
### 逻辑运算标志

以下标志声明对存储为键值的数据及其TTL（如果有）执行的操作类型，而不是元数据。
这些标志描述了命令在输入参数驱动下对数据执行的逻辑操作。
这些标志与修改或返回元数据（如键的类型、基数或存在性）无关。

每个关键规格可能会包含以下标记：

* **access:** 访问标志。
  此标志表示命令返回、复制或以某种方式使用存储在键中的用户数据。

此外，规范可能准确地包括以下之一：

* **update（更新）：**更新标志。
  该命令更新存储在键值中的数据。
  新值可能取决于旧值。
  此标志标记了不明确是插入还是删除的每个操作。
* **insert（插入）：**插入标志。
  该命令仅向值中添加数据；现有数据不会被修改或删除。
* **delete（删除）：**删除标志。
  该命令明确从存储在键中的值中删除数据。

### 杂项标志

关键规格可能具有以下标志：

* **not_key（非键）：** 这个标志表示指定的参数不是一个键。
  在计算Redis集群中命令应分配到哪个槽时，该参数将被视为一个键。但在其他所有情况下，该参数不应被视为一个键。
* **incomplete（不完整）：** 该标志的解释在下面说明。
* **variable_flags（可变标志）：** 该标志的解释在下面说明。

### 不完整

一些命令在指定键时采用了奇特的方法，这使得提取变得困难。
例如，考虑一下调用 `MIGRATE` 命令，并将字面字符串 _"KEYS"_ 作为参数传递给其 _AUTH_ 子句会发生什么。
我们的键规范会错误地开始提取，并且提取会从错误的索引开始。

因此，我们承认关键规格不完整，可能无法提取所有的键。
然而，我们保证即使规格不完整，只要命令在语法上是正确的，就不会给出错误的键名称。

在`MIGRATE`情况下，搜索从末尾开始（_startfrom_的值为_ -1_）。
如果我们遇到一个名为_"KEYS"_的键，我们只会提取它后面的键名参数的子集。
这就是为什么`MIGRATE`在其键规范中有一个_不完整（incomplete）_的标志。

另一个不完整的案例是`SORT`命令。
在这里，`begin_search`和`find_keys`的类型是_unknown_。
客户端应该回退到调用`COMMAND GETKEYS`命令来从参数中提取键名，而不是原生实现它。
困难在于，例如，字符串_"STORE"_既是关键字（标记）又是`SORT`的有效字面参数。

**注意：**
仅具有不完整关键规范的命令为`SORT`和`MIGRATE`。
我们不希望在将来添加这样的命令。

### 变量标志

在某些命令中，相同键名参数的标志位取值可以依赖于其他参数。
例如，考虑`SET`命令及其可选的_GET_参数。
如果没有_GET_参数，`SET`命令仅用于写入，但有了它之后，它就变成了读写命令。
当存在此标志位时，表示键名指定的标志位涵盖了所有可能的选项，但实际生效的标志位取决于其他参数。

## 示例

### `SET`的关键规格

```
  1) 1) "flags"
     2) 1) RW
        2) access
        3) update
     3) "begin_search"
     4) 1) "type"
        2) "index"
        3) "spec"
        4) 1) "index"
           2) (integer) 1
     5) "find_keys"
     6) 1) "type"
        2) "range"
        3) "spec"
        4) 1) "lastkey"
           2) (integer) 0
           3) "keystep"
           4) (integer) 1
           5) "limit"
           6) (integer) 0
```

### `ZUNION`的关键规范

```
  1) 1) "flags"
     2) 1) RO
        2) access
     3) "begin_search"
     4) 1) "type"
        2) "index"
        3) "spec"
        4) 1) "index"
           2) (integer) 1
     5) "find_keys"
     6) 1) "type"
        2) "keynum"
        3) "spec"
        4) 1) "keynumidx"
           2) (integer) 0
           3) "firstkey"
           4) (integer) 1
           5) "keystep"
           6) (integer) 1
```
